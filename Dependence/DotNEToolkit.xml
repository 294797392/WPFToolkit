<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DotNEToolkit</name>
    </assembly>
    <members>
        <member name="T:DotNEToolkit.Communictions.CommObject">
            <summary>
            通信对象模型
            </summary>
        </member>
        <member name="F:DotNEToolkit.Communictions.CommObject.EVENT_DATA_RECEIVED">
            <summary>
            当收到消息的时候触发
            </summary>
        </member>
        <member name="F:DotNEToolkit.Communictions.CommObject.EVENT_STATUS_CHANGED">
            <summary>
            当连接状态改变的时候触发
            </summary>
        </member>
        <member name="F:DotNEToolkit.Communictions.CommObject.newline">
            <summary>
            在读取或写入一行数据的时候使用的换行符
            </summary>
        </member>
        <member name="M:DotNEToolkit.Communictions.CommObject.IsOpened">
            <summary>
            判断IO设备是否已经打开
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Communictions.CommObject.Open">
            <summary>
            打开一个IO设备
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Communictions.CommObject.Close">
            <summary>
            关闭IO设备
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Communictions.CommObject.ReadLine">
            <summary>
            从通信设备里读取一行数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Communictions.CommObject.WriteLine(System.String)">
            <summary>
            向通信设备里写入一行数据
            </summary>
            <param name="line"></param>
        </member>
        <member name="M:DotNEToolkit.Communictions.CommObject.ReadBytes(System.Int32)">
            <summary>
            从通信设备里读取一段数据
            </summary>
            <param name="size">要读取的数据大小</param>
            <returns>读取的字节数</returns>
        </member>
        <member name="M:DotNEToolkit.Communictions.CommObject.WriteBytes(System.Byte[])">
            <summary>
            向通信设备里写入一段数据
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="T:DotNEToolkit.Communictions.CommObjectFactory">
            <summary>
            创建通信对象的工厂
            </summary>
        </member>
        <member name="T:DotNEToolkit.Communictions.CommTypes">
            <summary>
            定义通信对象的类型
            </summary>
        </member>
        <member name="F:DotNEToolkit.Communictions.CommTypes.SerialPort">
            <summary>
            串口通信设备
            </summary>
        </member>
        <member name="F:DotNEToolkit.Communictions.CommTypes.TcpClient">
            <summary>
            TCP客户端设备
            </summary>
        </member>
        <member name="F:DotNEToolkit.Communictions.CommTypes.TcpService">
            <summary>
            TCP服务
            </summary>
        </member>
        <member name="T:DotNEToolkit.Communictions.SerialPortCommObject">
            <summary>
            封装串口通信对象
            </summary>
        </member>
        <member name="T:DotNEToolkit.Communictions.TcpClientCommObject">
            <summary>
            封装Tcp客户端通信对象
            </summary>
        </member>
        <member name="T:DotNEToolkit.Crypto.CRC">
            <summary>
            CRC校验
            </summary>
        </member>
        <member name="M:DotNEToolkit.Crypto.CRC.StringToHexByte(System.String)">
            <summary>
            字符串转16进制字符数组
            </summary>
            <param name="hex"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Crypto.CRC.StringToHexByte(System.String,System.Boolean)">
            <summary>
            字符串转16进制字符数组
            </summary>
            <param name="str"></param>
            <param name="isFilterChinese">是否过滤掉中文字符</param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Crypto.AbstractCryptor">
            <summary>
            加解密抽象类
            </summary>
        </member>
        <member name="P:DotNEToolkit.Crypto.AbstractCryptor.SupportDecrypto">
            <summary>
            加密算法是否支持解密
            </summary>
        </member>
        <member name="P:DotNEToolkit.Crypto.AbstractCryptor.EncryptoKey">
            <summary>
            加解密用到的Key
            </summary>
        </member>
        <member name="P:DotNEToolkit.Crypto.AbstractCryptor.DecryptoKey">
            <summary>
            解密用到的Key
            </summary>
        </member>
        <member name="M:DotNEToolkit.Crypto.AbstractCryptor.Encrypto">
            <summary>
            加密操作
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Crypto.AbstractCryptor.EncryptoBase64">
            <summary>
            加密后的数据进行Base64处理
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Crypto.AbstractCryptor.Decrypto(System.Byte[])">
            <summary>
            解密操作
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.DateTimeFormat">
            <summary>
            提供日期格式化字符串
            </summary>
        </member>
        <member name="F:DotNEToolkit.DateTimeFormat.yyyyMMddhhmmss">
            <summary>
            格式化成202008180927的格式
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBCAPS.DSBCAPS_LOCHARDWARE">
            <summary>
            缓冲区存储在声卡里, 混音是在声卡里做的
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBCAPS.DSBCAPS_LOCSOFTWARE">
            <summary>
            缓冲区存储在内存里, 混音是CPU做的
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBCAPS.DSBCAPS_CTRL3D">
            <summary>
            The sound source can be moved in 3D space. 
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBCAPS.DSBCAPS_CTRLFREQUENCY">
            <summary>
            可以控制声音的频率
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBCAPS.DSBCAPS_CTRLPAN">
            <summary>
            The sound source can be moved from left to right. 
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBCAPS.DSBCAPS_CTRLVOLUME">
            <summary>
            可获取或设置音量大小
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBCAPS.DSBCAPS_CTRLPOSITIONNOTIFY">
            <summary>
            缓冲区通知功能
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBCAPS.DSBCAPS_CTRLFX">
            <summary>
            Effects can be added to the buffer. 
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBCAPS.DSBCAPS_GLOBALFOCUS">
            <summary>
            失去焦点继续播放功能
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBPLAY.DSBPLAY_LOOPING">
            <summary>
            缓冲区播放完毕之后从缓冲区开始的位置继续播放, 当播放主缓冲区的时候必须设置DSBPLAY_LOOPING
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSBUFFERDESC.dwBufferBytes">
            <summary>
            播放或者捕获缓冲区大小
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSCBUFFERDESC.dwFlags">
            <summary>
            指定设备能力, 可以为0, 
            DSCBCAPS_CTRLFX:（支持音效的Buffer）
            只支持从DirectSoundCaptureCreate8函数创建的设备对象, 需要WindowsXP版本（Capture effects require Microsoft Windows XP）
            DSCBCAPS_WAVEMAPPED（The Win32 wave mapper will be used for formats not supported by the device.）
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSCBUFFERDESC.dwBufferBytes">
            <summary>
            捕获缓冲区大小, 字节为单位
            缓冲区大小设置为传输速率, 那么每一个缓冲区就存储了一秒钟的声音数据
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSCBUFFERDESC.dwReserved">
            <summary>
            保留字段, 供以后使用
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSCBUFFERDESC.lpwfxFormat">
            <summary>
            要捕获的波形声音的格式信息
            tWAVEFORMATEX结构体指针
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSCBUFFERDESC.dwFXCount">
            <summary>
            一定为0, 除非dwFlag字段设置了DSCBCAPS_CTRLFX标志
            </summary>
        </member>
        <member name="T:DotNEToolkit.DirectSound.DSERR">
            <summary>
            DirectSound return values
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSSCL.DSSCL_NORMAL">
            <summary>
            Sets the normal level. This level has the smoothest multitasking and resource-sharing behavior, but because it does not allow the primary buffer format to change, output is restricted to the default 8-bit format. 
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSSCL.DSSCL_PRIORITY">
            <summary>
            Sets the priority level. Applications with this cooperative level can call the SetFormat and Compact methods. 
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSSCL.DSSCL_EXCLUSIVE">
            <summary>
            For DirectX 8.0 and later, has the same effect as DSSCL_PRIORITY. For previous versions, sets the application to the exclusive level. This means that when it has the input focus, the application will be the only one audible; sounds from applications with the DSBCAPS_GLOBALFOCUS flag set will be muted. With this level, it also has all the privileges of the DSSCL_PRIORITY level. DirectSound will restore the hardware format, as specified by the most recent call to the SetFormat method, after the application gains the input focus. 
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.DSSCL.DSSCL_WRITEPRIMARY">
            <summary>
            Sets the write-primary level. The application has write access to the primary buffer. No secondary buffers can be played. This level cannot be set if the DirectSound driver is being emulated for the device; that is, if the GetCaps method returns the DSCAPS_EMULDRIVER flag in the DSCAPS structure. 
            </summary>
        </member>
        <member name="M:DotNEToolkit.DirectSound.IDirectSoundBuffer8.Lock(System.UInt32,System.UInt32,System.IntPtr@,System.UInt32@,System.IntPtr@,System.UInt32@,System.UInt32)">
            <summary>
            
            </summary>
            <param name="dwOffset">Offset, in bytes, from the start of the buffer to the point where the lock begins. This parameter is ignored if DSBLOCK_FROMWRITECURSOR is specified in the dwFlags parameter. </param>
            <param name="dwBytes"></param>
            <param name="ppvAudioPtr1"></param>
            <param name="pdwAudioBytes1"></param>
            <param name="ppvAudioPtr2"></param>
            <param name="pdwAudioBytes2"></param>
            <param name="dwFlags">
            DSBLOCK_FROMWRITECURSOR : Start the lock at the write cursor. The dwOffset parameter is ignored.
            DSBLOCK_ENTIREBUFFER : Lock the entire buffer. The dwBytes parameter is ignored.
            </param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.DirectSound.IDirectSoundBuffer8.Play(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
            <param name="dwReserved1">必须为0</param>
            <param name="dwPriority">声音优先级, 当分配硬件混合资源的时候用来管理声音, 最低级别为0, 最高级别0xFFFFFFFF, 如果缓冲区创建的时候没有设置DSBCAPS_LOCDEFER标志, 那么取值必须为0</param>
            <param name="dwFlags"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.DirectSound.IDirectSoundCapture8.GetCaps(DotNEToolkit.DirectSound.DSCCAPS@)">
            <summary>
            获取捕获音频设备的信息
            </summary>
            <param name="pDSCCaps">DSCCAPS结构体指针, 必须指定dwSize字段</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.DirectSound.IDirectSoundCaptureBuffer8.GetCurrentPosition(System.Int32@,System.Int32@)">
            <summary>
            获取当前捕获位置
            </summary>
            <param name="pdwCapturePosition">Capture指针在缓冲中的位置</param>
            <param name="pdwReadPosition">Read指针在缓冲中的位置</param>
            <remarks>
            Read指针是指名当前你可以读到哪个位置，而不是从哪个位置开始读，比如第一次取数据的时候，会取缓冲的最开始位置到Read指针所指的位置。
            又由于是一个环形的缓冲，所以Capture指针的位置不一定总是大于Read指针的，可以理解成，Capture表明了在调用这个函数时正在录取的数据将要写到（为止）的位置，而Read是已经写好了的到这个位置为止的位置。
            所以我们在读取数据的时候要保存一个偏移量，记录每次要读取的数据的起始位置
            </remarks>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.DirectSound.IDirectSoundCaptureBuffer8.Lock(System.UInt32,System.UInt32,System.IntPtr@,System.Int32@,System.IntPtr@,System.Int32@,System.Int32)">
            <summary>
            The Lock method locks a portion of the buffer. Locking the buffer returns pointers into the buffer, allowing the application to read or write audio data into memory.
            </summary>
            <param name="dwOffset">Offset, in bytes, from the start of the buffer to the point where the lock begins. </param>
            <param name="dwBytes">Size, in bytes, of the portion of the buffer to lock. Because the buffer is conceptually circular, this number can exceed the number of bytes between dwOffset and the end of the buffer. </param>
            <param name="ppvAudioPtr1"></param>
            <param name="pdwAudioBytes1"></param>
            <param name="ppvAudioPtr2"></param>
            <param name="pdwAudioBytes2"></param>
            <param name="dwFlags">Flags modifying the lock event. This value can be zero or the following flag: DSCBLOCK_ENTIREBUFFER  Ignore dwBytes and lock the entire capture buffer.  </param>
            <returns></returns>
        </member>
        <member name="F:DotNEToolkit.DirectSound.WAVEFORMATEX.nChannels">
            <summary>
            通道数量
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.WAVEFORMATEX.nSamplesPerSec">
            <summary>
            采样率, 每秒采样次数
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.WAVEFORMATEX.nAvgBytesPerSec">
            <summary>
            设置声音数据的传输速率, 每秒平均传输的字节数, 单位byte/s, 如果wFormatTag = WAVE_FORMAT_PCM, nAvgBytesPerSec为nBlockAlign * nSamplesPerSec, 对于非PCM格式请根据厂商的说明计算
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.WAVEFORMATEX.nBlockAlign">
            <summary>
            以字节为单位设置块对齐。块对齐是指最小数据的原子大小，如果wFormatTag = WAVE_FORMAT_PCM, nBlockAlign为(nChannels * wBitsPerSample) / 8, 对于非PCM格式请根据厂商的说明计算
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.WAVEFORMATEX.wBitsPerSample">
            <summary>
            采样位数, 每个采样的位数
            如果wFormatTag是WAVE_FORMAT_PCM, 必须设置为8或者16, 其他的不支持
            如果wFormatTag是WAVE_FORMAT_EXTENSIBLE, 必须设置为8的倍数, 一些压缩方法不定义此值, 所以此值可以为0
            </summary>
        </member>
        <member name="F:DotNEToolkit.DirectSound.WAVEFORMATEX.cbSize">
            <summary>
            额外信息的大小，以字节为单位，额外信息添加在WAVEFORMATEX结构的结尾。这个信息可以作为非PCM格式的wFormatTag额外属性，如果wFormatTag不需要额外的信息，此值必需为0，对于PCM格式此值被忽略。
            </summary>
        </member>
        <member name="T:DotNEToolkit.Colors">
            <summary>
            提供颜色转换函数
            </summary>
        </member>
        <member name="M:DotNEToolkit.Colors.ConvertRGB(System.String,System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            十六进制的颜色转rgb
            支持以井号开头或者不以井号开头的十六进制颜色值
            </summary>
            <param name="color"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name=""></param>
        </member>
        <member name="P:DotNEToolkit.Excels.Attributes.ExcelColumnAttribute.Name">
            <summary>
            列名字
            </summary>
        </member>
        <member name="P:DotNEToolkit.Excels.Attributes.ExcelColumnAttribute.Type">
            <summary>
            列的数据类型
            </summary>
        </member>
        <member name="T:DotNEToolkit.Excels.ExcelCell">
            <summary>
            表示Exce里的一个单元格的信息
            </summary>
        </member>
        <member name="T:DotNEToolkit.Excels.ExcelCellTypes">
            <summary>
            表示Excel里的Cell的类型
            </summary>
        </member>
        <member name="F:DotNEToolkit.Excels.ExcelCellTypes.Null">
            <summary>
            是一个空值
            </summary>
        </member>
        <member name="F:DotNEToolkit.Excels.ExcelCellTypes.Numberic">
            <summary>
            数字类型
            </summary>
        </member>
        <member name="F:DotNEToolkit.Excels.ExcelCellTypes.String">
            <summary>
            字符串类型
            </summary>
        </member>
        <member name="T:DotNEToolkit.Excels.ExcelRow">
            <summary>
            表示Excel里的某一行
            </summary>
        </member>
        <member name="P:DotNEToolkit.Excels.ExcelRow.Cells">
            <summary>
            这一行里一共多少列有数据
            </summary>
        </member>
        <member name="T:DotNEToolkit.Excels.ExcelSheet">
            <summary>
            表示一个Excel的工作表
            </summary>
        </member>
        <member name="P:DotNEToolkit.Excels.ExcelSheet.Rows">
            <summary>
            工作表里的所有的行数据
            </summary>
        </member>
        <member name="F:DotNEToolkit.Excels.ExcelVersions.Xls">
            <summary>
            Excel 97 - 2003版本
            </summary>
        </member>
        <member name="F:DotNEToolkit.Excels.ExcelVersions.Xlsx">
            <summary>
            Excel 2007版本
            </summary>
        </member>
        <member name="T:DotNEToolkit.Excels.IExcelObject">
            <summary>
            表示一个可以保存为Excel文件的对象
            或者表示一个可以从Excel文件读取的一个对象
            </summary>
        </member>
        <member name="T:DotNEToolkit.Excels.IExcelRow">
            <summary>
            表示Excel里的一行
            </summary>
        </member>
        <member name="T:DotNEToolkit.Excels.ReadOptions">
            <summary>
            指定对Excel里的空列的处理方式
            </summary>
        </member>
        <member name="F:DotNEToolkit.Excels.ReadOptions.IgnoreEmptyCell">
            <summary>
            忽略Excel里的空列
            </summary>
        </member>
        <member name="F:DotNEToolkit.Excels.ReadOptions.KeepEmptyCell">
            <summary>
            保留Excel里的空列（会保存一个空对象在ExcelRow里）
            </summary>
        </member>
        <member name="T:DotNEToolkit.Excel">
            <summary>
            封装Excel文件的导入，导出功能
            </summary>
        </member>
        <member name="M:DotNEToolkit.Excel.QuickWrite(System.String,System.Object[0:,0:],System.String,DotNEToolkit.Excels.ExcelVersions)">
            <summary>
            把一个二维数组写到Excel里
            </summary>
            <param name="filePath"></param>
            <param name="excelData">一维是行，二维是列</param>
            <param name="sheetName"></param>
            <param name="version"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Expressions.AccessMember">
            <summary>
            存储要访问的成员信息
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.AccessMember.Name">
            <summary>
            要访问的成员名称
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.AccessMember.Type">
            <summary>
            成员类型
            </summary>
        </member>
        <member name="T:DotNEToolkit.Expressions.AccessMemberProperty">
            <summary>
            表示一个属性成员
            </summary>
        </member>
        <member name="T:DotNEToolkit.Expressions.ExpressionTypes">
            <summary>
            表达式类型
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ExpressionTypes.MacroDefinition">
            <summary>
            宏定义
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ExpressionTypes.StringConstant">
            <summary>
            字符串常量
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ExpressionTypes.Function">
            <summary>
            函数表达式
            </summary>
        </member>
        <member name="T:DotNEToolkit.Expressions.MemberTypes">
            <summary>
            表示成员类型
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.MemberTypes.Property">
            <summary>
            该成员是一个属性
            </summary>
        </member>
        <member name="T:DotNEToolkit.Expressions.IEvaluationContext">
            <summary>
            计算表达式需要的上下文信息
            该接口是一个标记接口，没有任何内容
            </summary>
        </member>
        <member name="T:DotNEToolkit.Expressions.Evaluators.ExpressionEvaluator">
            <summary>
            表达式求值程序
            当你需要实现一个表达式的时候，只要继承并实现这个类就可以了
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.Evaluators.ExpressionEvaluator.MinimalParameters">
            <summary>
            最少要多少个参数
            </summary>
        </member>
        <member name="M:DotNEToolkit.Expressions.Evaluators.ExpressionEvaluator.Evaluate(DotNEToolkit.Expressions.Expression,DotNEToolkit.Expressions.IEvaluationContext)">
            <summary>
            计算表达式
            这个函数会对表达式进行一些计算前的校验操作，比如参数是不是合法..etc..
            真正计算表达式的逻辑在EvaluateCore函数里
            子类必须实现EvaluateCore函数
            </summary>
            <param name="expression"></param>
            <param name="context"></param>
            <returns>
            返回null则表示失败，否则成功
            </returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.Evaluators.ExpressionEvaluator.EvaluateCore(DotNEToolkit.Expressions.Expression,DotNEToolkit.Expressions.IEvaluationContext)">
            <summary>
            真正的计算表达式的逻辑
            子类必须实现该类
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Expressions.Expression">
            <summary>
            表达式树的子节点
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.Expression.Parent">
            <summary>
            父节点
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.Expression.Type">
            <summary>
            表达式类型
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.Expression.Name">
            <summary>
            表达式名字
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.Expression.Parameters">
            <summary>
            表达式参数列表
            也就是子表达式求值之后的结果
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.Expression.Children">
            <summary>
            子表达式
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.Expression.Value">
            <summary>
            表达式的值
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.Expression.AccessMembers">
            <summary>
            存储要访问的成员信息
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.Expression.State">
            <summary>
            表达式状态
            </summary>
        </member>
        <member name="T:DotNEToolkit.Expressions.ExpressionParser">
            <summary>
            表达式解析器
            1. 把表达式字符串解析为一个树形结构
            2. 对树形结构进行求值计算
            
            在进行表达式求值的时候，会优先使用系统里预定义的表达式求值程序
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ExpressionParser.userDefinedFile">
            <summary>
            用户定义的表达式配置文件路径
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ExpressionParser.leftBracket">
            <summary>
            记录左括号的数量
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ExpressionParser.rightBracket">
            <summary>
            记录右括号的数量
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ExpressionParser.preDefinedEvas">
            <summary>
            缓存所有的表达式计算器
            </summary>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.#ctor(System.String)">
            <summary>
            ExpressionParser构造方法
            </summary>
            <param name="exprFile">要加载的表达式求值程序JSON配置文件，配置文件格式请参考Expressions/predefined.exp.json</param>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.IsSpace(System.Char)">
            <summary>
            判断是否是空格，如果是空格那么忽略掉
            </summary>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.IsParamFunctionIndicator(System.Char)">
            <summary>
            是否是函数表达式字符
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.IsParamEntryIndicator(System.Char)">
            <summary>
            判断是否开始解析函数参数
            如果遇到了‘(’左括号，那么表示开始解析函数参数
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.IsParamStringValid(System.Char)">
            <summary>
            判断是否是有效的字符串参数
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.IsParamStringIndicator(System.Char)">
            <summary>
            判断是否是字符串参数
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.IsParamSplitter(System.Char)">
            <summary>
            判断是否是参数分隔符
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.IsAccessMemberEntryIndicator(System.Char)">
            <summary>
            判断是否是成员访问符
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.IsParamMemberValid(System.Char)">
            <summary>
            判断是否是有效的成员参数
            </summary>
            <param name="ch">要判断的字符</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.IsAccessArrayIndicator(System.Char)">
            <summary>
            判断字符是否是访问数组成员
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.IsAccessFunctionIndicator(System.Char)">
            <summary>
            判断字符是否是访问函数成员
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.EventGround(System.Char,DotNEToolkit.Expressions.Expression)">
            <summary>
            基态
            该函数处理以下几件事：
            1. 忽略空格键
            2. 判断是否是字符串参数，如果是则转到字符串参数状态
            3. 判断是否是函数参数，如果是则转到函数参数状态
            4. 判断是否是属性参数，如果是则转到属性参数状态
            5. 如果是参数分隔符则清空当前的参数
            </summary>
            <param name="ch"></param>
            <param name="parent"></param>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.EventParamFunction(System.Char,DotNEToolkit.Expressions.Expression)">
            <summary>
            处理函数状态
            </summary>
            <param name="ch"></param>
            <param name="parent"></param>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.EventParamTermination(System.Char,DotNEToolkit.Expressions.Expression)">
            <summary>
            处理ParamTermination状态下出现的字符
            字符串状态下出现了第二个单引号触发该状态
            
            该函数做以下几件事：
            1. 判断如果出现的左括号的次数等于右括号的次数，那么说明整个函数解析完了，跳转到基态
            2. 判断函数结束后面是否有成员访问符
            </summary>
            <param name="ch"></param>
            <param name="parent"></param>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.BuildExpressionTree(System.String)">
            <summary>
            构造表达式树形列表
            </summary>
            <param name="expression"></param>
        </member>
        <!-- 对于成员“M:DotNEToolkit.Expressions.ExpressionParser.Evaluate(DotNEToolkit.Expressions.Expression,DotNEToolkit.Expressions.IEvaluationContext)”忽略有格式错误的 XML 注释 -->
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.TryGetEvaluator(System.String,System.Collections.Generic.List{DotNEToolkit.Expressions.ExpressionDefinition},System.Collections.Generic.Dictionary{System.String,DotNEToolkit.Expressions.Evaluators.ExpressionEvaluator})">
            <summary>
            从指定的表达式定义列表和表达式求值程序池里查找一个表达式求值程序
            如果从表达式列表里找到了，那么反射实例化该表达式求值程序并把求值程序实例缓存到求值程序池里
            </summary>
            <param name="name">要查找的表达式的名字</param>
            <param name="exprDefines">表达式定义列表</param>
            <param name="evaluators">求值程序池</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.LoadDefinitions(System.String)">
            <summary>
            从给定的路径加载一个表达式定义列表
            </summary>
            <param name="exprFile">要加载的表达式定义文件路径</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.GetEvaluator(System.String)">
            <summary>
            根据表达式名字获取表达式求值程序的实例
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.EvaluateExpression(DotNEToolkit.Expressions.Expression,DotNEToolkit.Expressions.IEvaluationContext)">
            <summary>
            计算指定表达式的值
            </summary>
            <param name="expression"></param>
            <param name="code">
            表达式计算的返回值，0表示成功，非0表示失败，失败的错误码由调用者定义
            </param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Expressions.ExpressionParser.InvokeAccessPropertyMember(System.String,System.Object)">
            <summary>
            访问某个对象的属性，返回属性值
            </summary>
            <param name="amp"></param>
            <param name="source">要访问的对象</param>
            <returns>
            返回null则表示失败，否则成功
            </returns>
        </member>
        <member name="T:DotNEToolkit.Expressions.ExpressionDefinition">
            <summary>
            表达式求值程序定义
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.ExpressionDefinition.Syntax">
            <summary>
            表达式语法
            </summary>
        </member>
        <member name="P:DotNEToolkit.Expressions.ExpressionDefinition.MinimalParameters">
            <summary>
            表达式最少要拥有多少个参数才能计算
            如果在计算的时候小于这个值，那么就返回计算失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ExpressionState.HasEvaluation">
            <summary>
            已经求过值了
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ExpressionState.WaitEvaluation">
            <summary>
            等待求值
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ParserState.Ground">
            <summary>
            初始状态
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ParserState.ParamFunction">
            <summary>
            当前状态是函数参数状态
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ParserState.ParamString">
            <summary>
            当前是字符串类型的参数
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ParserState.ParamTermination">
            <summary>
            字符串参数结束状态
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ParserState.AccessMemberEntry">
            <summary>
            成员访问状态入口，当出现了'.'符号的时候就会进入这个状态
            对象的成员有如下机种状态：
            1. 属性，以逗号结尾
            2. 函数，以左括号开头，右括号结尾
            3. 数组，以左中括号开头，右中括号结尾
            </summary>
        </member>
        <member name="F:DotNEToolkit.Expressions.ParserState.GrammarError">
            <summary>
            语法错误状态
            </summary>
        </member>
        <member name="T:DotNEToolkit.FileItem">
            <summary>
            存储一个要打包的文件信息
            </summary>
        </member>
        <member name="P:DotNEToolkit.FileItem.Name">
            <summary>
            文件名字
            </summary>
        </member>
        <member name="P:DotNEToolkit.FileItem.Content">
            <summary>
            文件内容
            </summary>
        </member>
        <member name="T:DotNEToolkit.DirectoryItem">
            <summary>
            存储一个要打包的目录信息
            </summary>
        </member>
        <member name="P:DotNEToolkit.DirectoryItem.BackslashPath">
            <summary>
            带有反斜杠的路径
            SharpZipLib会把带有反斜杠结束的名字当成一个目录来处理
            所以在把目录写入压缩包的时候要带反斜杠
            </summary>
        </member>
        <member name="P:DotNEToolkit.DirectoryItem.Path">
            <summary>
            目录名字
            压缩包里的完整路径
            </summary>
        </member>
        <member name="P:DotNEToolkit.DirectoryItem.FileList">
            <summary>
            该目录下的所有文件
            </summary>
        </member>
        <member name="M:DotNEToolkit.DirectoryItem.Size">
            <summary>
            计算目录的总大小
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.FilePackages">
            <summary>
            定义可以打包的文件类型
            </summary>
        </member>
        <member name="F:DotNEToolkit.FilePackages.Zip">
            <summary>
            Zip压缩包格式的打包
            后缀名.zip
            </summary>
        </member>
        <member name="F:DotNEToolkit.FilePackages.Stored">
            <summary>
            不压缩，直接保存
            当压缩很耗时的时候可以考虑此方法
            后缀名.zip
            </summary>
        </member>
        <member name="T:DotNEToolkit.FilePackage">
            <summary>
            将文件流或者目录打包成一个文件（包括但不限于压缩文件）保存
            支持流式打包
            </summary>
        </member>
        <member name="F:DotNEToolkit.FilePackage.packageFilePath">
            <summary>
            最终的压缩包的名字
            </summary>
        </member>
        <member name="P:DotNEToolkit.FilePackage.Type">
            <summary>
            打包文件的类型
            </summary>
        </member>
        <member name="M:DotNEToolkit.FilePackage.Create(System.String,DotNEToolkit.FilePackages)">
            <summary>
            创建一个压缩包
            </summary>
            <param name="package">要创建的压缩包类型</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.FilePackage.PackDir(System.String)">
            <summary>
            读取一个本地目录并进行打包
            </summary>
            <param name="dir"></param>
        </member>
        <member name="M:DotNEToolkit.FilePackage.AppendDirectory(System.Collections.Generic.List{DotNEToolkit.DirectoryItem})">
            <summary>
            往一个已经存在的打包文件里追加目录列表
            </summary>
            <param name="packagePath">已经存在的打包文件完整路径</param>
            <param name="dirList">要追加到打包文件里的目录列表</param>
        </member>
        <member name="T:DotNEToolkit.ZIPFilePackage">
            <summary>
            使用SharpZipLib库实现的文件打包器
            </summary>
        </member>
        <member name="T:DotNEToolkit.Log4net">
            <summary>
            提供Log4Net的帮助函数
            </summary>
        </member>
        <member name="M:DotNEToolkit.Log4net.InitializeLog4net(System.String)">
            <summary>
            初始化Log4net库
            默认使用程序根目录下的log4net.xml配置文件初始化log4net
            </summary>
        </member>
        <member name="T:DotNEToolkit.Modular.IHostedModule">
            <summary>
            表示一个要在其他进程运行的模块
            在ModuleHost里会通过反射机制创建IHostedModule的实例并调用Initialize方法
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.IHostedModule.Initialize(System.Collections.IDictionary)">
            <summary>
            初始化该模块
            </summary>
            <param name="parameters">该模块的参数</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.IHostedModule.Release">
            <summary>
            释放该模块所占用的资源
            </summary>
        </member>
        <member name="T:DotNEToolkit.Modular.AbstractHostedModule">
            <summary>
            运行在ModuleHosted里的模块
            运行在外部进程的模块基类
            如果你的模块想运行在外部进程，那么可以实现这个抽象类
            这个类实现了与主进程通信的功能
            调用者只需要关心主进程发送过来的命令并处理就可以了
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.AbstractHostedModule.KEY_COMM_TYPE">
            <summary>
            进程间通信方式
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.AbstractHostedModule.OnClientDataReceived(System.Int32,System.Object)">
            <summary>
            当收到客户端进程发过来的消息的时候被调用
            </summary>
            <param name="cmdType"></param>
            <param name="cmdParam"></param>
        </member>
        <member name="M:DotNEToolkit.Modular.AbstractHostedModule.Send(System.Int32,System.Byte[])">
            <summary>
            给外部进程发消息
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.AbstractHostedModule.Send(System.Int32,System.String)">
            <summary>
            给外部进程发消息
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.AbstractHostedModule.Send(System.Int32,System.Object)">
            <summary>
            给外部进程发消息
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.AbstractHostedModule.OnInitialize(System.Collections.IDictionary)">
            <summary>
            初始化子类
            </summary>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.AbstractHostedModule.OnRelease">
            <summary>
            释放子类占用的资源
            </summary>
        </member>
        <member name="T:DotNEToolkit.Modular.ModuleHostModule">
            <summary>
            一个专门运行ModuleHost的模块
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleHostModule.OnInitialize">
            <summary>
            初始化ModuleHost
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Modular.ModuleHostProxy">
            <summary>
            一个用来和ModuleHost进行通信的代理模块
            该类维护与远程模块的连接状态
            调用者只需要关心子进程发送过来的命令并处理就可以了
            主要的函数：OnDataReceived - 收到子进程发送的消息的时候触发
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleHostProxy.commClient">
            <summary>
            用来和ModuleHost模块进行通信的客户端
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleHostProxy.OnDataReceived(System.Int32,System.Object)">
            <summary>
            当收到了ModuleHost发送过来的消息的时候触发
            </summary>
            <param name="cmdType">命令类型</param>
            <param name="cmdParam">命令参数</param>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleHostProxy.Send(System.Int32,System.Byte[])">
            <summary>
            给外部进程发消息
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleHostProxy.Send(System.Int32,System.String)">
            <summary>
            给外部进程发消息
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleHostProxy.Send(System.Int32,System.Object)">
            <summary>
            给外部进程发消息
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Modular.ServiceModule">
            <summary>
            服务是一个一直在后台默默运行的模块
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.ServiceModule.Start">
            <summary>
            开始运行服务
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ServiceModule.Stop">
            <summary>
            停止运行服务
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.ServiceModule.OnStart">
            <summary>
            在服务开始的时候被调用
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ServiceModule.OnStop">
            <summary>
            在服务结束的时候被调用
            </summary>
        </member>
        <member name="T:DotNEToolkit.Modular.Attributes.ModuleInputAttribute">
            <summary>
            定义模块的输入参数
            1. 工作流设计器使用
            2. 方便开发者一眼就可以看到模块有哪些输出值
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.Attributes.ModuleInputAttribute.Key">
            <summary>
            参数的键
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.Attributes.ModuleInputAttribute.ValueType">
            <summary>
            参数类型
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.Attributes.ModuleInputAttribute.Description">
            <summary>
            参数描述
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.Attributes.ModuleInputAttribute.Optional">
            <summary>
            该参数是否是可选参数
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.Attributes.ModuleInputAttribute.IsClass">
            <summary>
            表示该输入是否是一个类类型
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.Attributes.ModuleInputAttribute.#ctor(System.String,System.String,System.Type,System.Boolean)">
            <summary>
            
            </summary>
            <param name="description"></param>
            <param name="key"></param>
            <param name="valueType"></param>
            <param name="optional">true：可空，false：不可空</param>
        </member>
        <member name="M:DotNEToolkit.Modular.Attributes.ModuleInputAttribute.#ctor(System.String,System.Type,System.Boolean)">
            <summary>
            当输入是一个类类型使用
            </summary>
            <param name="description"></param>
            <param name="optional"></param>
        </member>
        <member name="M:DotNEToolkit.Modular.Attributes.ModuleInputAttribute.#ctor(System.String,System.Boolean)">
            <summary>
            当输入是一个属性类型的时候使用
            </summary>
            <param name="description"></param>
            <param name="optional"></param>
        </member>
        <member name="T:DotNEToolkit.Modular.Attributes.ModulePropertyAttribute">
            <summary>
            表示一个模块的公开属性
            </summary>
        </member>
        <member name="T:DotNEToolkit.Modular.Attributes.ModuleActionAttribute">
            <summary>
            表示一个模块的调用操作
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.Attributes.ModuleActionAttribute.Name">
            <summary>
            动作的名字
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.Attributes.ModuleActionAttribute.Manually">
            <summary>
            是否在界面上手动触发
            </summary>
        </member>
        <member name="T:DotNEToolkit.Modular.Attributes.ModuleInstanceAttribute">
            <summary>
            工作流设计器使用
            </summary>
        </member>
        <member name="T:DotNEToolkit.Modular.Attributes.ModuleOutputAttribute">
            <summary>
            定义模块的输出数据
            1. 工作流设计器使用
            2. 方便开发者一眼就可以看到模块有哪些输出值
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.IConfigReader.Initialize(System.String)">
            <summary>
            初始化Reader
            </summary>
            <param name="configPath"></param>
        </member>
        <member name="M:DotNEToolkit.Modular.IConfigReader.ReadValue(System.String)">
            <summary>
            读取配置项
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Modular.IModuleInstance">
            <summary>
            模块实例公共接口
            </summary>
        </member>
        <member name="E:DotNEToolkit.Modular.IModuleInstance.PublishEvent">
            <summary>
            当前模块有事件的时候触发
            第一个参数：事件发送者
            第二个参数：事件类型
            第三个参数：事件参数（由用户定义）
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.IModuleInstance.Status">
            <summary>
            模块状态
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.IModuleInstance.ID">
            <summary>
            模块ID
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.IModuleInstance.Name">
            <summary>
            模块名称
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.IModuleInstance.Description">
            <summary>
            描述
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.IModuleInstance.Definition">
            <summary>
            描述文件
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.IModuleInstance.Factory">
            <summary>
            所属的工厂
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.IModuleInstance.Initialize(System.Collections.IDictionary)">
            <summary>
            初始化模块
            </summary>
            <param name="parameters">模块的输入参数</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.IModuleInstance.Release">
            <summary>
            释放模块
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Modular.ModuleBase">
            <summary>
            表示一个抽象的模块
            </summary>
        </member>
        <member name="E:DotNEToolkit.Modular.ModuleBase.PublishEvent">
            <summary>
            当前模块有事件触发的时候触发
            第一个参数：事件发送者
            第二个参数：事件代码
            第二个参数：eventXml（由用户定义）
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleBase.Status">
            <summary>
            模块当前的状态
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleBase.ID">
            <summary>
            模块ID
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleBase.Name">
            <summary>
            模块名字
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleBase.Description">
            <summary>
            模块的描述信息
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleBase.Definition">
            <summary>
            模块的定义
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleBase.Factory">
            <summary>
            模块所属工厂
            在ModuleFactory里被赋值
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleBase.Properties">
            <summary>
            模块当前的输出参数
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleBase.InputParameters">
            <summary>
            模块的输入参数
            不要使用这个参数去获取配置参数，而是使用Initialize方法里穿进去的parameter去获取配置参数
            因为InputParameters参数里有可能有绑定参数，需要动态计算
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleBase.Initialize(System.Collections.IDictionary)">
            <summary>
            初始化模块
            </summary>
            <param name="parameters">模块参数</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleBase.Release">
            <summary>
            释放模块占用的资源
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleBase.GetInputValue``1(System.String,``0)">
            <summary>
            从InputParameter里读取一个对象
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleBase.GetInputObject``1(System.String,``0)">
            <summary>
            从InputParameter里读取一个JSON对象
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="defaultObject">如果不存在该对象，那么要返回的默认值</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleBase.PubEvent(System.Int32,System.Object)">
            <summary>
            发布一个事件，该事件只有订阅了该事件的模块才能收到
            </summary>
            <param name="eventType">事件代码</param>
            <param name="eventData">事件参数</param>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleBase.OnInitialize">
            <summary>
            子类初始化
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleBase.OnRelease">
            <summary>
            子类释放资源
            </summary>
        </member>
        <member name="T:DotNEToolkit.Modular.ModuleDefinition">
            <summary>
            存储模块的信息
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleDefinition.ID">
            <summary>
            模块ID
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleDefinition.Name">
            <summary>
            模块名字
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleDefinition.Description">
            <summary>
            描述
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleDefinition.MetadataID">
            <summary>
            组件类型ID
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleDefinition.ClassName">
            <summary>
            模块的完整类型名
            如果该值不为空，那么优先根据该值去创建实例
            如果该值为空，那么会根据MetadataID去创建实例
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleDefinition.Flags">
            <summary>
            模块的标志位
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleDefinition.InputParameters">
            <summary>
            输入配置参数
            执行模块的构造方法的时候，会动态把所依赖的模块实例反射并赋值给该模块的属性
            避免了每次都要调用LookupModule去查找模块，麻烦
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleDefinition.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleDefinition.HasFlag(System.Int32)">
            <summary>
            判断该模块是否包含指定的选项
            </summary>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleDefinition.SetFlag(System.Int32)">
            <summary>
            设置该模块的选项
            </summary>
            <param name="flag"></param>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleDefinition.CloneInputParameters">
            <summary>
            克隆一份输入参数
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Modular.ModuleEvent">
            <summary>
            提供一组预定义的模块事件
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleEvent.MessageEvent">
            <summary>
            模块向外部输出消息
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleEvent.StatusChanged">
            <summary>
            模块状态发生改变
            </summary>
        </member>
        <member name="T:DotNEToolkit.Modular.ModuleFactory">
            <summary>
            模块工厂
            
            功能描述：
                模块工厂通过读取JSON配置文件，加载JSON配置文件里的所有模块并提供接口获取某个模块
                自动识别modules.*.json的文件为模块元数据文件
                ModuleFactory从模块元数据文件里根据MetadataID去查找对应模块的ClassName
            </summary>
        </member>
        <member name="E:DotNEToolkit.Modular.ModuleFactory.Initialized">
            <summary>
            当所有模块都加载完成的时候触发
            只有在异步加载模块的时候才会触发
            </summary>
        </member>
        <member name="E:DotNEToolkit.Modular.ModuleFactory.ModuleEvent">
            <summary>
            当模块出发了一个事件的时候触发
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleFactory.MetadataList">
            <summary>
            所有模块的元数据信息
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleFactory.ModuleList">
            <summary>
            存储已经加载了的模块
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.LookupModuleMetadatas">
            <summary>
            读取所有的类型定义
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.InitializeModule(DotNEToolkit.Modular.ModuleBase,System.Int32)">
            <summary>
            初始化一个模块，直到该模块初始化成功为止
            如果初始化失败，那么会一直初始化
            </summary>
            <param name="moduleInst">要初始化的模块</param>
            <param name="interval">重新初始化的间隔时间</param>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.CreateFactory(System.String)">
            <summary>
            根据配置文件加载ModuleFactory
            同步接口
            </summary>
            <param name="moduleFile">模块文件</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.CreateFactory(System.Collections.Generic.IEnumerable{DotNEToolkit.Modular.ModuleDefinition})">
            <summary>
            创建一个模块工厂并同步初始化模块实例
            </summary>
            <param name="initialModules">要初始化的模块实例</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.CreateFactory">
            <summary>
            创建一个空的工厂
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.SetupAsync(System.String,System.Int32)">
            <summary>
            异步初始化ModuleFactory
            </summary>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.SetupModulesAsync(System.Collections.Generic.IEnumerable{DotNEToolkit.Modular.ModuleDefinition},System.Int32)">
            <summary>
            异步加载模块
            如果模块连接失败，该函数会自动重连模块
            </summary>
            <param name="initialModules"></param>
            <param name="interval">自动重连模块的间隔时间</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.SetupModules(System.Collections.Generic.IEnumerable{DotNEToolkit.Modular.ModuleDefinition})">
            <summary>
            同步加载一组组件，加载失败会直接返回，不会尝试重新加载
            </summary>
            <param name="modules">要加载的模块列表</param>
            <returns>是否加载成功</returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.SetupModule(DotNEToolkit.Modular.ModuleDefinition)">
            <summary>
            同步加载一个模块，如果加载失败则直接返回
            不会尝试重新加载
            </summary>
            <param name="module"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.CreateModule``1(DotNEToolkit.Modular.ModuleDefinition)">
            <summary>
            根据模块定义创建一个模块实例
            但是不初始化它
            如果要创建并初始化，那么请调用SetupModule
            </summary>
            <param name="module">模块定义</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.ReleaseModule(System.String)">
            <summary>
            删除并释放某个模块
            </summary>
            <param name="moduleID"></param>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.LookupModule``1(System.String)">
            <summary>
            根据ID查找系统中可用的组件
            如果ID为空，则返回第一个可用的组件
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.LookupModule``1">
            <summary>
            查找指定类型的组件，如果有多个，则返回第一个
            </summary>
            <typeparam name="TModuleInstance"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Modular.ModuleFactory.SubclassOf(DotNEToolkit.Modular.ModuleDefinition,System.Type)">
            <summary>
            判断某个Module是否派生自baseType
            </summary>
            <param name="definition"></param>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Modular.ModuleFactoryDescription">
            <summary>
            定义ModuleFactory的配置
            </summary>
        </member>
        <member name="T:DotNEToolkit.Modular.ModuleFlags">
            <summary>
            模块的标志位
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleFlags.Disabled">
            <summary>
            模块被禁用
            告诉ModuleFactory不要加载该模块
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleFlags.WaitableTask">
            <summary>
            该模块是一个可等待的任务
            </summary>
        </member>
        <member name="T:DotNEToolkit.Modular.ModuleStatus">
            <summary>
            表示一个模块的状态
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleStatus.UnInitialized">
            <summary>
            空闲状态
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleStatus.Initialized">
            <summary>
            模块初始化成功
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleStatus.InitializeFailed">
            <summary>
            初始化失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleStatus.Initializing">
            <summary>
            初始化中
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleStatus.InitializeException">
            <summary>
            初始化异常
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleStatus.StartPending">
            <summary>
            服务正在启动
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleStatus.StopPending">
            <summary>
            服务正在启动
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleStatus.Running">
            <summary>
            服务已经启动
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleStatus.Stopped">
            <summary>
            服务已停止
            </summary>
        </member>
        <member name="F:DotNEToolkit.Modular.ModuleStatus.StartupException">
            <summary>
            启动异常
            </summary>
        </member>
        <member name="T:DotNEToolkit.Modular.ModuleMetadata">
            <summary>
            存储模块的元数据信息
            ModuleFactory通过TypeID找到ModuleMetadata，然后动态创建模块实例
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleMetadata.ID">
            <summary>
            唯一标志符
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleMetadata.Name">
            <summary>
            模块的默认的名字
            </summary>
        </member>
        <member name="P:DotNEToolkit.Modular.ModuleMetadata.ClassName">
            <summary>
            模块的完整类型名
            </summary>
        </member>
        <member name="T:DotNEToolkit.MySQLInstaller">
            <summary>
            封装Windows下绿色版mysql的安装程序逻辑
            把这个程序放到Mysql/bin目录下，然后运行
            </summary>
        </member>
        <member name="F:DotNEToolkit.MySQLInstaller.DefualtMysqlConfig">
            <summary>
            默认的Mysql配置文件内容
            </summary>
        </member>
        <member name="E:DotNEToolkit.MySQLInstaller.Progress">
            <summary>
            安装进度回调
            </summary>
        </member>
        <member name="M:DotNEToolkit.MySQLInstaller.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="mysqlDir">mysql的基目录</param>
        </member>
        <member name="M:DotNEToolkit.MySQLInstaller.Install">
            <summary>
            把Mysql安装成一个Windows服务
            </summary>
        </member>
        <member name="M:DotNEToolkit.MySQLInstaller.Uninstall">
            <summary>
            卸载Mysql Windows服务
            </summary>
        </member>
        <member name="T:DotNEToolkit.ProcessComm.NamedPipeCommClient">
            <summary>
            使用WCF NamedPipe进行进程间通信的客户端
            </summary>
        </member>
        <member name="F:DotNEToolkit.ProcessComm.NamedPipeCommClient.serviceChannel">
            <summary>
            与服务端进程进行通信的通道
            </summary>
        </member>
        <member name="F:DotNEToolkit.ProcessComm.NamedPipeCommClient.namedPipeHost">
            <summary>
            用来接受服务端连接的ServiceHost
            </summary>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.NamedPipeCommClient.SendBytes(System.Int32,System.Byte[])">
            <summary>
            当服务端发送数据过来的时候触发
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.INamedPipeChannel.SendBytes(System.Int32,System.Byte[])">
            <summary>
            向对方发送消息
            </summary>
            <param name="cmdParam">要发送的消息</param>
        </member>
        <member name="T:DotNEToolkit.ProcessComm.INamedPipeServiceChannel">
            <summary>
            客户端访问服务器使用的接口
            </summary>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.INamedPipeServiceChannel.Connect">
            <summary>
            客户端连接服务端
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.INamedPipeServiceChannel.Disconnect">
            <summary>
            客户端断开与服务端的连接
            </summary>
        </member>
        <member name="T:DotNEToolkit.ProcessComm.INamedPipeClientChannel">
            <summary>
            服务器访问客户端使用的接口
            </summary>
        </member>
        <member name="T:DotNEToolkit.ProcessComm.NamedPipeCommSvc">
            <summary>
            使用WCF NamedPipe实现的IPC服务端
            
            参考：https://www.cnblogs.com/zhili/p/WCFCallbackOperacation.html
            
            WCF支持服务将调用返回给它的客户端。
            在回调期间，服务成为了客户端，而客户端成为了服务。
            在WCF中，并不是所有的绑定都支持回调操作，只有具有双向能力的绑定才能够用于回调。
            例如，HTTP本质上是与连接无关的，所以它不能用于回调，因此我们不能基于basicHttpBinding和wsHttpBinding绑定使用回调。
            WCF为NetTcpBinding和NetNamedPipeBinding提供了对回调的支持，因为TCP和IPC协议都支持双向通信。
            为了让Http支持回调，WCF提供了WsDualHttpBinding绑定，它实际上设置了两个Http通道：一个用于从客户端到服务的调用，另一个用于服务到客户端的调用。
            </summary>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.NamedPipeCommSvc.Send(System.Int32,System.Byte[])">
            <summary>
            向客户端发消息
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.NamedPipeCommSvc.Connect">
            <summary>
            客户端连接的时候触发
            如果客户端连接，那么说明客户端此时也启动了一个NamedPipeServiceHost
            那么此时服务端就可以连接客户端的ServiceHost，实现双向通信的功能
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.NamedPipeCommSvc.Disconnect">
            <summary>
            客户端断开连接的时候触发
            </summary>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.NamedPipeCommSvc.SendBytes(System.Int32,System.Byte[])">
            <summary>
            客户端有数据发送过来的时候触发
            </summary>
            <param name="data"></param>
        </member>
        <member name="E:DotNEToolkit.ProcessComm.ProcessCommClient.StatusChanged">
            <summary>
            当客户端的连接状态改变的时候触发
            </summary>
        </member>
        <member name="P:DotNEToolkit.ProcessComm.ProcessCommClient.Status">
            <summary>
            客户端的当前状态
            </summary>
        </member>
        <member name="P:DotNEToolkit.ProcessComm.ProcessCommClient.ServiceURI">
            <summary>
            要连接的服务端的地址
            </summary>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.ProcessCommClient.Initialize">
            <summary>
            初始化IPC
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.ProcessCommClient.Release">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.ProcessCommClient.Connect">
            <summary>
            连接IPC进程
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.ProcessCommClient.Disconnect">
            <summary>
            与IPC进程断开连接
            </summary>
        </member>
        <member name="T:DotNEToolkit.ProcessComm.CommClientStates">
            <summary>
            定义通信客户端的状态
            </summary>
        </member>
        <member name="F:DotNEToolkit.ProcessComm.CommClientStates.ConnectFailed">
            <summary>
            连接失败
            </summary>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.ProcessCommFactory.CreateNamedPipeServiceHost``1(System.String,System.Object)">
            <summary>
            创建一个WCF NamedPipe服务主机
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.ProcessComm.ProcessCommObject">
            <summary>
            提供进程间通信对象的通用接口
            </summary>
        </member>
        <member name="E:DotNEToolkit.ProcessComm.ProcessCommObject.DataReceived">
            <summary>
            当收到客户端发送过来的命令的时候触发
            int：命令类型
            object：命令参数，可能是byte数组，可能是string，也可能是一个对象
            </summary>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.ProcessCommObject.Send(System.Int32,System.Object)">
            <summary>
            向进程发送一个对象
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.ProcessCommObject.Send(System.Int32,System.String)">
            <summary>
            发送一条命令
            </summary>
            <param name="cmdType">命令类型</param>
            <param name="cmdParams">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.ProcessCommObject.Send(System.Int32,System.Byte[])">
            <summary>
            发送一条命令
            </summary>
            <param name="cmdType">命令类型</param>
            <param name="cmdParams">字节数组类型的命令参数</param>
            <returns></returns>
        </member>
        <member name="P:DotNEToolkit.ProcessComm.ProcessCommSvc.URI">
            <summary>
            该服务端的地址
            </summary>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.ProcessCommSvc.Initialize">
            <summary>
            初始化IPC
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.ProcessCommSvc.Release">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.ProcessCommSvc.Start">
            <summary>
            运行IPC服务
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ProcessComm.ProcessCommSvc.Stop">
            <summary>
            停止运行IPC服务
            </summary>
        </member>
        <member name="T:DotNEToolkit.ProcessComm.ProcessCommTypes">
            <summary>
            定义进程间通信的方式
            </summary>
        </member>
        <member name="F:DotNEToolkit.ProcessComm.ProcessCommTypes.WCFNamedPipe">
            <summary>
            WCF NetNamedPipe绑定
            </summary>
        </member>
        <member name="F:DotNEToolkit.ProcessComm.ProcessCommTypes.SharedMemory">
            <summary>
            使用共享内存实现的IPC通信
            </summary>
        </member>
        <member name="F:DotNEToolkit.ProcessComm.ProcessCommTypes.TCP">
            <summary>
            使用TCP实现的IPC通信
            </summary>
        </member>
        <member name="T:DotNEToolkit.StringTerminator">
            <summary>
            指定StringEnumerator使用的换行符
            </summary>
        </member>
        <member name="F:DotNEToolkit.StringTerminator.CR">
            <summary>
            StringEnumerator会把换行符转换成CR
            </summary>
        </member>
        <member name="F:DotNEToolkit.StringTerminator.LF">
            <summary>
            StringEnumerator会把换行符转换成LF
            </summary>
        </member>
        <member name="T:DotNEToolkit.StringEnumerator">
            <summary>
            实现一个增强版的CharEnumerator
            1. 该Enumerator提供了Peek的功能
            2. 提供了MoveUntil函数
            3. 提供了CharPosition属性标识当前字符的位置
            </summary>
        </member>
        <member name="F:DotNEToolkit.StringEnumerator.peeks">
            <summary>
            peek的次数
            每次调用MoveNext的时候peeks会清零
            </summary>
        </member>
        <member name="P:DotNEToolkit.StringEnumerator.CharPosition">
            <summary>
            获取当前字符的位置
            </summary>
        </member>
        <member name="P:DotNEToolkit.StringEnumerator.Current">
            <summary>
            当前的字符
            </summary>
        </member>
        <member name="P:DotNEToolkit.StringEnumerator.Peeked">
            <summary>
            当前Peek的字符
            </summary>
        </member>
        <member name="M:DotNEToolkit.StringEnumerator.MoveNext">
            <summary>
            向前Move一个字符
            每次Move都会重置Peek指针
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.StringEnumerator.MoveNext(System.Int32)">
            <summary>
            向前move step个字符
            </summary>
            <param name="step"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.StringEnumerator.MoveNext(System.Char)">
            <summary>
            向前move，遇到ignore字符直接忽略并继续move
            </summary>
            <param name="ignore">要忽略的字符</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.StringEnumerator.MoveNext(System.Char,System.String@)">
            <summary>
            向前Move，直到Move到until为止
            每次Move都会重置Peek指针
            </summary>
            <param name="until">要move到的字符</param>
            <param name="moved">保存move到的字符串，不包含until</param>
            <returns>
            如果Move到了until，那么返回true，否则返回false
            </returns>
        </member>
        <member name="M:DotNEToolkit.StringEnumerator.Peek">
            <summary>
            向前peek，会移动Peek指针
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.StringEnumerator.Reset">
            <summary>
            重置指针状态
            </summary>
        </member>
        <member name="T:DotNEToolkit.Media.AudioPlay">
            <summary>
            一个简单的PCM播放器
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.AudioPlay.Channel">
            <summary>
            采样通道数
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.AudioPlay.SamplesPerSec">
            <summary>
            采样率
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.AudioPlay.BitsPerSample">
            <summary>
            每个采样大小是16位
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.AudioPlay.BlockAlign">
            <summary>
            块对齐, 每个采样的字节数
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.AudioPlay.BytesPerSec">
            <summary>
            一秒钟音频所占空间大小
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.AudioPlay.BufferSize">
            <summary>
            捕获缓冲区大小和播放缓冲区大小
            缓冲区里的数据是一秒钟的音频数据
            </summary>
        </member>
        <member name="M:DotNEToolkit.Media.AudioPlay.PlayFile(System.String)">
            <summary>
            播放一个音频文件
            该方法是同步方法，会阻塞当前线程直到音频文件播放完了为止
            </summary>
            <param name="fileURI">要播放的音频文件的地址</param>
        </member>
        <member name="T:DotNEToolkit.Media.AudioPlayType">
            <summary>
            录音机类型
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.AudioPlayType.DirectSound">
            <summary>
            使用DirectSound录音
            </summary>
        </member>
        <member name="T:DotNEToolkit.Media.AudioRecordType">
            <summary>
            录音机类型
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.AudioRecordType.DirectSound">
            <summary>
            使用DirectSound录音
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.AudioRecordType.WaveAPI">
            <summary>
            使用waveIn API录音
            </summary>
        </member>
        <member name="T:DotNEToolkit.Media.AudioRecordFactory">
            <summary>
            录音机工厂
            </summary>
        </member>
        <member name="T:DotNEToolkit.Media.PCMFormats">
            <summary>
            规定PCM数据的存储格式
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.PCMFormats.S16_LE">
            <summary>
            有符号16位整数，小尾端
            DirectSound默认存储方式
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.PCMFormats.S16_BE">
            <summary>
            有符号16位整数，大尾端
            </summary>
        </member>
        <member name="T:DotNEToolkit.Media.Audio">
            <summary>
            提供音频数据相关的工具函数
            
            分贝是一个相对量，相对于某一个标准值的倍数取对数，得到的就是贝尔Bell，分贝则是贝尔的十分之一。比如以10为标准，那么1000就是2Bell，也就是20dB。
            计算分贝的公式：10 * log10(x / std)
            
            PCM数据存储格式：
            1. 8位单声道：
            2. 8位双声道：
            3. 16位单声道：
            4. 16位双声道：
            </summary>
        </member>
        <member name="M:DotNEToolkit.Media.Audio.CalculateDb(System.Byte[],System.Int32,DotNEToolkit.Media.PCMFormats,System.Collections.Generic.List{System.Double}@)">
            <summary>
            计算音频数据的dbFS值
            </summary>
            <param name="channels">PCM数据</param>
            <param name="pcm">通道数</param>
            <param name="formats">PCM数据存储方式</param>
            <param name="volume">声音音量，百分比单位</param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Media.G711">
            <summary>
            提供G711数据编解码函数
            
            https://www.jianshu.com/p/33cba1a821d0
            g711a输入的是13位（S16的高13位），这种格式是经过特别设计的，便于数字设备进行快速运算。
            G711的内容是将14bit(uLaw)或者13bit(aLaw)采样的PCM数据编码成8bit的数据流，播放的时候在将此8bit的数据还原成14bit或者13bit进行播放，不同于MPEG这种对于整体或者一段数据进行考虑再进行编解码的做法，G711是波形编解码算法，就是一个sample对应一个编码，所以压缩比固定为：
            8/14 = 57% (uLaw)
            8/13 = 62% (aLaw)
            </summary>
        </member>
        <member name="M:DotNEToolkit.Media.G711.Alaw2PCM(System.Byte[])">
            <summary>
            alaw转PCM
            </summary>
            <param name="alaw"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Media.G711.Ulaw2PCM(System.Byte[])">
            <summary>
            ulaw转PCM
            </summary>
            <param name="ulaw"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Media.WaveAPIRecord">
            <summary>
            使用waveIn API开发的录音程序
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.WaveAPIRecord.free_pwh">
            <summary>
            WaveHeader指针
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.WaveAPIRecord.hwi">
            <summary>
            WaveIn Hwnd
            </summary>
        </member>
        <member name="T:DotNEToolkit.Media.AudioDevice">
            <summary>
            表示一个声卡设备
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.AudioDevice.Name">
            <summary>
            声卡设备的显示名字
            </summary>
        </member>
        <member name="T:DotNEToolkit.Media.AudioRecord">
            <summary>
            一个录制PCM音频的录音机
            </summary>
        </member>
        <member name="E:DotNEToolkit.Media.AudioRecord.DataReceived">
            <summary>
            录到了数据会触发
            </summary>
        </member>
        <member name="E:DotNEToolkit.Media.AudioRecord.Failed">
            <summary>
            当录音过程中遇到错误的时候触发
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.AudioRecord.filePath">
            <summary>
            要保存的音频文件路径
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.AudioRecord.fileStream">
            <summary>
            保存的音频流文件
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.AudioRecord.usedDevice">
            <summary>
            当前正在使用的声卡设备
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.AudioRecord.Channel">
            <summary>
            采样通道数
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.AudioRecord.SamplesPerSec">
            <summary>
            采样率
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.AudioRecord.BitsPerSample">
            <summary>
            每个采样大小是16位
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.AudioRecord.BlockAlign">
            <summary>
            块对齐, 每个采样的字节数
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.AudioRecord.BytesPerSec">
            <summary>
            一秒钟音频所占空间大小
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.AudioRecord.BufferSize">
            <summary>
            捕获缓冲区大小和播放缓冲区大小
            缓冲区里的数据是一秒钟的音频数据
            </summary>
        </member>
        <member name="M:DotNEToolkit.Media.AudioRecord.Start">
            <summary>
            开始录音
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Media.AudioRecord.Stop">
            <summary>
            停止录音
            </summary>
        </member>
        <member name="M:DotNEToolkit.Media.AudioRecord.GetAudioDevices">
            <summary>
            枚举系统里所有的录音设备（可以录音的声卡）
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Media.AudioRecord.SetRecordFile(System.String)">
            <summary>
            设置录音文件的保存路径
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:DotNEToolkit.Media.AudioRecord.SetAudioDevice(DotNEToolkit.Media.AudioDevice)">
            <summary>
            设置录音程序使用的声卡
            </summary>
            <param name="device"></param>
        </member>
        <member name="T:DotNEToolkit.Media.DirectSoundRecord">
            <summary>
            DirectSound录音出来的数据是小尾端的数据
            无符号16位数据
            大尾端就是高位在低地址，小尾端就是低位在低地址。
            </summary>
        </member>
        <member name="P:DotNEToolkit.Media.DirectSoundRecord.DirectSoundAudioDevice.ID">
            <summary>
            设备的GUID
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.DirectSoundRecord.NotifyEvents">
            <summary>
            音频缓冲区通知对象的个数
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.DirectSoundRecord.dsc8">
            <summary>
            IDirectSoundCapture8
            </summary>
        </member>
        <member name="F:DotNEToolkit.Media.DirectSoundRecord.dscb8">
            <summary>
            IDirectSoundCaptureBuffer8
            </summary>
        </member>
        <member name="M:DotNEToolkit.Networks.GetMACAddress">
            <summary>
            获取所有网卡的MAC地址
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Numberics">
            <summary>
            操作数字的帮助函数
            </summary>
        </member>
        <member name="M:DotNEToolkit.Numberics.FixedDecimal(System.Double,System.Int32)">
            <summary>
            保留num位小数，会四舍五入
            </summary>
            <param name="src"></param>
            <param name="num"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Numberics.IsHexadecimal(System.Char)">
            <summary>
            判断一个字符是否是十六进制字符
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Numberics.AccumulateTo(System.Int32,System.Int32)">
            <summary>
            函数功能：
            如果value是437，ch是2，那么返回的结果就是4372
            
            从terminal项目拷贝
            </summary>
            <param name="value"></param>
            <param name="add"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Marshals">
            <summary>
            提供PInvoke的公共函数
            </summary>
        </member>
        <member name="M:DotNEToolkit.Marshals.CreateStructurePointer(System.Object)">
            <summary>
            结构体转byte数组
            注意，该函数会从非托管空间开辟内存
            在指针不用的时候需要调用FreeStructurePtr释放内存
            </summary>
            <param name="structObj">要转换的结构体</param>
            <returns>指向结构体的指针</returns>
        </member>
        <member name="M:DotNEToolkit.Marshals.FreeStructurePointer(System.IntPtr)">
            <summary>
            释放用StructureToPtr函数分配的结构体指针
            </summary>
            <param name="structPtr">要释放的指针</param>
        </member>
        <member name="T:DotNEToolkit.Bindings.BindableBase">
            <summary>
            表示一个属性可绑定的对象
            可依赖注入的对象
            
            可以让普通的对象像WPF里的DependecyObject一样，对DependencyObject的属性进行绑定（WPF是在XAML里绑定）。
            这样就不用每次都对属性赋值了，可以更专注于每个类的业务逻辑的开发，没有了很多属性的赋值操作，代码可读性也更强，同时也弱化了类与类之间的耦合性
            </summary>
        </member>
        <member name="P:DotNEToolkit.Bindings.BindablePropertyAttribute.DefaultValue">
            <summary>
            成员的默认值
            </summary>
        </member>
        <member name="T:DotNEToolkit.BufferQueue`1">
            <summary>
            Queue
            用于生产者消费者的缓冲池。和传统模式不同的是，当待处理队列已满时，策略是丢弃某个对象而不是让生产者等待
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:DotNEToolkit.BufferQueue`1.MaxPoolSize">
            <summary>
            缓冲池最大允许长度，0 表示没有最大长度
            </summary>
        </member>
        <member name="P:DotNEToolkit.BufferQueue`1.Size">
            <summary>
            获取队列里元素的数量
            </summary>
        </member>
        <member name="M:DotNEToolkit.BufferQueue`1.Enqueue(`0)">
            <summary>
            将缓冲对象进入缓冲池
            </summary>
            <param name="t"></param>
            <returns>0 没有任何遗弃，1 缓冲池已满，遗弃一个对象</returns>
        </member>
        <member name="M:DotNEToolkit.BufferQueue`1.Dequeue">
            <summary>
            取出一个缓冲对象.如果池中已空，将会挂起线程等待
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.ConfigFactory`1">
            <summary>
            根据配置文件生成相应的实例
            </summary>
        </member>
        <member name="P:DotNEToolkit.ConfigFactory`1.ConfigKey">
            <summary>
            Factory 读取AppSetting配置所用的key
            </summary>
        </member>
        <member name="M:DotNEToolkit.ConfigFactory`1.CreateInstance">
            <summary>
            创建一个接口对象T的实例
            </summary>
            <typeparam name="T">需要实现的接口</typeparam>
            <returns></returns>
            <remarks>
            该函数将自动读取配置文件，并根据配置文件里AppSetting中ConfigKey所对应的值自动选择合适的实现。
            ConfigKey所对应的键值为所需接口T的完整类名。如果需要指定assembly名, 则在类名后用逗号隔开
            例如："ICare.EventSender.DirectSender, EventSender"
            </remarks>
        </member>
        <member name="M:DotNEToolkit.ConfigFactory`1.CreateInstance(System.String,System.String)">
            <summary>
            根据类名和Assebmly名创建IEventDispatcher
            </summary>
            <param name="className"></param>
            <param name="assemblyName"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ConfigFactory`1.CreateInstance(System.String,System.Object[])">
            <summary>
            根据指定类名创建IEventDispatcher
            </summary>
            <param name="className"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.AccessBase.GetModels``1(DotNEToolkit.DataAccess.DBManager,System.String,System.Data.CommandType,System.Object[])">
            <summary>
            Sql参数必须以@0, @1，@2等方式写出，args次序需和sql中的一致
            </summary>
            <typeparam name="T"></typeparam>
            <param name="dbManager"></param>
            <param name="sql"></param>
            <param name="commandType"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.AccessBase.GetModel``1(DotNEToolkit.DataAccess.DBManager,System.String,System.Data.CommandType,System.Object[])">
            <summary>
            Sql参数必须以@0, @1，@2等方式写出，args次序需和sql中的一致
            </summary>
            <typeparam name="T"></typeparam>
            <param name="dbManager"></param>
            <param name="sql"></param>
            <param name="commandType"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="F:DotNEToolkit.DataAccess.DbFactory.sqlServerCeProviderInst">
            <summary>
            SqlServerCe Provider缓存实例
            </summary>
        </member>
        <member name="F:DotNEToolkit.DataAccess.DbFactory.oracleProviderInst">
            <summary>
            Oracle Provider缓存实例
            </summary>
        </member>
        <member name="F:DotNEToolkit.DataAccess.DbFactory.mysqlProviderInst">
            <summary>
            MySql Provider缓存实例
            </summary>
        </member>
        <member name="F:DotNEToolkit.DataAccess.DbFactory.sqliteProviderInst">
            <summary>
            Sqlite Provider缓存实例
            </summary>
        </member>
        <member name="P:DotNEToolkit.DataAccess.DBField.IsAutoIncrement">
            <summary>
            是否为自增列
            </summary>
        </member>
        <member name="P:DotNEToolkit.DataAccess.DBField.IsKey">
            <summary>
            是否为主键
            </summary>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.AttachParameters(System.Data.Common.DbCommand,System.Data.Common.DbParameter[])">
            <summary>
            This method is used to attach array of DbParameters to a DbCommand.
            
            This method will assign a value of DbNull to any parameter with a direction of
            InputOutput and a value of null.  
            
            This behavior will prevent default values from being used, but
            this will be the less common case than an intended pure output parameter (derived as InputOutput)
            where the user provided no input value.
            </summary>
            <param name="command">The command to which the parameters will be added</param>
            <param name="commandParameters">An array of DbParameters to be added to command</param>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.AssignParameterValues(System.Data.Common.DbParameter[],System.Data.DataRow)">
            <summary>
            This method assigns dataRow column values to an array of DbParameters
            </summary>
            <param name="commandParameters">Array of DbParameters to be assigned values</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values</param>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.AssignParameterValues(System.Data.Common.DbParameter[],System.Object[])">
            <summary>
            This method assigns an array of values to an array of DbParameters
            </summary>
            <param name="commandParameters">Array of DbParameters to be assigned values</param>
            <param name="parameterValues">Array of objects holding the values to be assigned</param>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.PrepareCommand(System.Data.Common.DbCommand,System.Data.Common.DbConnection,System.Data.Common.DbTransaction,System.Data.CommandType,System.String,System.Data.Common.DbParameter[],System.Boolean@)">
            <summary>
            This method opens (if necessary) and assigns a connection, transaction, command type and parameters 
            to the provided command
            </summary>
            <param name="command">The DbCommand to be prepared</param>
            <param name="connection">A valid DbConnection, on which to execute this command</param>
            <param name="transaction">A valid DbTransaction, or 'null'</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-Sql command</param>
            <param name="commandParameters">An array of DbParameters to be associated with the command or 'null' if no parameters are required</param>
            <param name="mustCloseConnection"><c>true</c> if the connection was opened by the method, otherwose is false.</param>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.CreateCommand(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.String[])">
            <summary>
            Simplify the creation of a Db command object by allowing
            a stored procedure and optional parameters to be provided
            </summary>
            <remarks>
            e.g.:  
             DbCommand command = CreateCommand(conn, "AddCustomer", "CustomerID", "CustomerName");
            </remarks>
            <param name="connection">A valid DbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="sourceColumns">An array of string to be assigned as the source columns of the stored procedure parameters</param>
            <returns>A valid DbCommand object</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteNonQuery(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns no resultset and takes no parameters) against the database specified in 
            the connection string
            </summary>
            <remarks>
            e.g.:  
             int result = ExecuteNonQuery(connString, CommandType.StoredProcedure, "PublishOrders");
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-Sql command</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteNonQuery(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns no resultset) against the database specified in the connection string 
            using the provided parameters
            </summary>
            <remarks>
            e.g.:  
             int result = ExecuteNonQuery(connString, CommandType.StoredProcedure, "PublishOrders", new DbParameter("@prodid", 24));
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteNonQuery(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns no resultset) against the database specified in 
            the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             int result = ExecuteNonQuery(connString, "PublishOrders", 24, 36);
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="spName">The name of the stored prcedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteNonQuery(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns no resultset and takes no parameters) against the provided DbConnection. 
            </summary>
            <remarks>
            e.g.:  
             int result = ExecuteNonQuery(conn, CommandType.StoredProcedure, "PublishOrders");
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-Sql command</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteNonQuery(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns no resultset) against the specified DbConnection 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             int result = ExecuteNonQuery(conn, CommandType.StoredProcedure, "PublishOrders", new DbParameter("@prodid", 24));
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteNonQuery(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns no resultset) against the specified DbConnection 
            using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             int result = ExecuteNonQuery(conn, "PublishOrders", 24, 36);
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteNonQuery(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns no resultset and takes no parameters) against the provided DbTransaction. 
            </summary>
            <remarks>
            e.g.:  
             int result = ExecuteNonQuery(trans, CommandType.StoredProcedure, "PublishOrders");
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteNonQuery(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns no resultset) against the specified DbTransaction
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             int result = ExecuteNonQuery(trans, CommandType.StoredProcedure, "GetOrders", new DbParameter("@prodid", 24));
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteNonQuery(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns no resultset) against the specified 
            DbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             int result = ExecuteNonQuery(conn, trans, "PublishOrders", 24, 36);
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An int representing the number of rows affected by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteDataset(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns a resultset and takes no parameters) against the database specified in 
            the connection string. 
            </summary>
            <remarks>
            e.g.:  
             DataSet ds = ExecuteDataset(connString, CommandType.StoredProcedure, "GetOrders");
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteDataset(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns a resultset) against the database specified in the connection string 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             DataSet ds = ExecuteDataset(connString, CommandType.StoredProcedure, "GetOrders", new DbParameter("@prodid", 24));
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteDataset(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns a resultset) against the database specified in 
            the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             DataSet ds = ExecuteDataset(connString, "GetOrders", 24, 36);
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteDataset(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns a resultset and takes no parameters) against the provided DbConnection. 
            </summary>
            <remarks>
            e.g.:  
             DataSet ds = ExecuteDataset(conn, CommandType.StoredProcedure, "GetOrders");
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteDataset(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns a resultset) against the specified DbConnection 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             DataSet ds = ExecuteDataset(conn, CommandType.StoredProcedure, "GetOrders", new DbParameter("@prodid", 24));
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteDataset(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns a resultset) against the specified DbConnection 
            using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             DataSet ds = ExecuteDataset(conn, "GetOrders", 24, 36);
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteDataset(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns a resultset and takes no parameters) against the provided DbTransaction. 
            </summary>
            <remarks>
            e.g.:  
             DataSet ds = ExecuteDataset(trans, CommandType.StoredProcedure, "GetOrders");
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteDataset(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns a resultset) against the specified DbTransaction
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             DataSet ds = ExecuteDataset(trans, CommandType.StoredProcedure, "GetOrders", new DbParameter("@prodid", 24));
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of SqlParamters used to execute the command</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteDataset(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns a resultset) against the specified 
            DbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             DataSet ds = ExecuteDataset(trans, "GetOrders", 24, 36);
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A dataset containing the resultset generated by the command</returns>
        </member>
        <member name="T:DotNEToolkit.DataAccess.DbHelper.DbConnectionOwnership">
            <summary>
            This enum is used to indicate whether the connection was provided by the caller, or created by DbHelper, so that
            we can set the appropriate CommandBehavior when calling ExecuteReader()
            </summary>
        </member>
        <member name="F:DotNEToolkit.DataAccess.DbHelper.DbConnectionOwnership.Internal">
            <summary>Connection is owned and managed by DbHelper</summary>
        </member>
        <member name="F:DotNEToolkit.DataAccess.DbHelper.DbConnectionOwnership.External">
            <summary>Connection is owned and managed by the caller</summary>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteReader(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.Common.DbTransaction,System.Data.CommandType,System.String,System.Data.Common.DbParameter[],DotNEToolkit.DataAccess.DbHelper.DbConnectionOwnership)">
            <summary>
            Create and prepare a DbCommand, and call ExecuteReader with the appropriate CommandBehavior.
            </summary>
            <remarks>
            If we created and opened the connection, we want the connection to be closed when the DataReader is closed.
            
            If the caller provided the connection, we want to leave it to them to manage.
            </remarks>
            <param name="connection">A valid DbConnection, on which to execute this command</param>
            <param name="transaction">A valid DbTransaction, or 'null'</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParameters to be associated with the command or 'null' if no parameters are required</param>
            <param name="connectionOwnership">Indicates whether the connection parameter was provided by the caller, or created by DbHelper</param>
            <returns>DbDataReader containing the results of the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteReader(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns a resultset and takes no parameters) against the database specified in 
            the connection string. 
            </summary>
            <remarks>
            e.g.:  
             DbDataReader dr = ExecuteReader(connString, CommandType.StoredProcedure, "GetOrders");
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-Sql command</param>
            <returns>A DbDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteReader(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns a resultset) against the database specified in the connection string 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             DbDataReader dr = ExecuteReader(connString, CommandType.StoredProcedure, "GetOrders", new DbParameter("@prodid", 24));
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>A DbDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteReader(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns a resultset) against the database specified in 
            the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             DbDataReader dr = ExecuteReader(connString, "GetOrders", 24, 36);
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A DbDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteReader(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns a resultset and takes no parameters) against the provided DbConnection. 
            </summary>
            <remarks>
            e.g.:  
             DbDataReader dr = ExecuteReader(conn, CommandType.StoredProcedure, "GetOrders");
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-Db command</param>
            <returns>A DbDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteReader(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns a resultset) against the specified DbConnection 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             DbDataReader dr = ExecuteReader(conn, CommandType.StoredProcedure, "GetOrders", new DbParameter("@prodid", 24));
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>A DbDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteReader(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns a resultset) against the specified DbConnection 
            using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             DbDataReader dr = ExecuteReader(conn, "GetOrders", 24, 36);
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A DbDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteReader(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns a resultset and takes no parameters) against the provided DbTransaction. 
            </summary>
            <remarks>
            e.g.:  
             DbDataReader dr = ExecuteReader(trans, CommandType.StoredProcedure, "GetOrders");
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>A DbDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteReader(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns a resultset) against the specified DbTransaction
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
              DbDataReader dr = ExecuteReader(trans, CommandType.StoredProcedure, "GetOrders", new DbParameter("@prodid", 24));
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>A DbDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteReader(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns a resultset) against the specified
            DbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             DbDataReader dr = ExecuteReader(trans, "GetOrders", 24, 36);
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A DbDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteScalar(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns a 1x1 resultset and takes no parameters) against the database specified in 
            the connection string. 
            </summary>
            <remarks>
            e.g.:  
             int orderCount = (int)ExecuteScalar(connString, CommandType.StoredProcedure, "GetOrderCount");
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteScalar(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns a 1x1 resultset) against the database specified in the connection string 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             int orderCount = (int)ExecuteScalar(connString, CommandType.StoredProcedure, "GetOrderCount", new DbParameter("@prodid", 24));
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteScalar(System.String,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns a 1x1 resultset) against the database specified in 
            the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             int orderCount = (int)ExecuteScalar(connString, "GetOrderCount", 24, 36);
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteScalar(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns a 1x1 resultset and takes no parameters) against the provided DbConnection. 
            </summary>
            <remarks>
            e.g.:  
             int orderCount = (int)ExecuteScalar(conn, CommandType.StoredProcedure, "GetOrderCount");
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteScalar(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns a 1x1 resultset) against the specified DbConnection 
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             int orderCount = (int)ExecuteScalar(conn, CommandType.StoredProcedure, "GetOrderCount", new DbParameter("@prodid", 24));
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteScalar(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns a 1x1 resultset) against the specified DbConnection 
            using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             int orderCount = (int)ExecuteScalar(conn, "GetOrderCount", 24, 36);
            </remarks>
            <param name="connection">A valid DbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteScalar(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String)">
            <summary>
            Execute a DbCommand (that returns a 1x1 resultset and takes no parameters) against the provided DbTransaction. 
            </summary>
            <remarks>
            e.g.:  
             int orderCount = (int)ExecuteScalar(trans, CommandType.StoredProcedure, "GetOrderCount");
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteScalar(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.Data.CommandType,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Execute a DbCommand (that returns a 1x1 resultset) against the specified DbTransaction
            using the provided parameters.
            </summary>
            <remarks>
            e.g.:  
             int orderCount = (int)ExecuteScalar(trans, CommandType.StoredProcedure, "GetOrderCount", new DbParameter("@prodid", 24));
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters used to execute the command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelper.ExecuteScalar(System.Data.Common.DbTransaction,DotNEToolkit.DataAccess.ProviderType,System.Int32,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via a DbCommand (that returns a 1x1 resultset) against the specified
            DbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            e.g.:  
             int orderCount = (int)ExecuteScalar(trans, "GetOrderCount", 24, 36);
            </remarks>
            <param name="transaction">A valid DbTransaction</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
        </member>
        <member name="T:DotNEToolkit.DataAccess.DbHelperParameterCache">
            <summary>
            DbHelperParameterCache provides functions to leverage a static cache of procedure parameters, and the
            ability to discover parameters for stored procedures at run-time.
            </summary>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelperParameterCache.DiscoverSpParameterSet(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.String,System.Boolean)">
            <summary>
            Resolve at run time the appropriate set of DbParameters for a stored procedure
            </summary>
            <param name="connection">A valid DbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="includeReturnValueParameter">Whether or not to include their return value parameter</param>
            <returns>The parameter array discovered.</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelperParameterCache.CloneParameters(System.Data.Common.DbParameter[])">
            <summary>
            Deep copy of cached DbParameter array
            </summary>
            <param name="originalParameters"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelperParameterCache.CacheParameterSet(System.String,System.String,System.Data.Common.DbParameter[])">
            <summary>
            Add parameter array to the cache
            </summary>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <param name="commandParameters">An array of DbParamters to be cached</param>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelperParameterCache.GetCachedParameterSet(System.String,System.String)">
            <summary>
            Retrieve a parameter array from the cache
            </summary>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="commandText">The stored procedure name or T-SQL command</param>
            <returns>An array of DbParamters</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelperParameterCache.GetSpParameterSet(System.String,DotNEToolkit.DataAccess.ProviderType,System.String)">
            <summary>
            Retrieves the set of DbParameters appropriate for the stored procedure
            </summary>
            <remarks>
            This method will query the database for this information, and then store it in a cache for future requests.
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <returns>An array of DbParameters</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelperParameterCache.GetSpParameterSet(System.String,DotNEToolkit.DataAccess.ProviderType,System.String,System.Boolean)">
            <summary>
            Retrieves the set of DbParameters appropriate for the stored procedure
            </summary>
            <remarks>
            This method will query the database for this information, and then store it in a cache for future requests.
            </remarks>
            <param name="connectionString">A valid connection string for a DbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="includeReturnValueParameter">A bool value indicating whether the return value parameter should be included in the results</param>
            <returns>An array of DbParameters</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelperParameterCache.GetSpParameterSet(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.String)">
            <summary>
            Retrieves the set of DbParameters appropriate for the stored procedure
            </summary>
            <remarks>
            This method will query the database for this information, and then store it in a cache for future requests.
            </remarks>
            <param name="connection">A valid DbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <returns>An array of DbParameters</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelperParameterCache.GetSpParameterSet(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.String,System.Boolean)">
            <summary>
            Retrieves the set of DbParameters appropriate for the stored procedure
            </summary>
            <remarks>
            This method will query the database for this information, and then store it in a cache for future requests.
            </remarks>
            <param name="connection">A valid DbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="includeReturnValueParameter">A bool value indicating whether the return value parameter should be included in the results</param>
            <returns>An array of DbParameters</returns>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DbHelperParameterCache.GetSpParameterSetInternal(System.Data.Common.DbConnection,DotNEToolkit.DataAccess.ProviderType,System.String,System.Boolean)">
            <summary>
            Retrieves the set of DbParameters appropriate for the stored procedure
            </summary>
            <param name="connection">A valid DbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="includeReturnValueParameter">A bool value indicating whether the return value parameter should be included in the results</param>
            <returns>An array of DbParameters</returns>
        </member>
        <member name="P:DotNEToolkit.DataAccess.DBManager.CommandTimeout">
            <summary>
            命令执行的缺省超时时间
            </summary>
        </member>
        <member name="M:DotNEToolkit.DataAccess.DBManager.FillDbParameters(System.Object[])">
            <summary>
            产生以@0, @1, @2...的一组DB变量
            </summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.DataModels.ModelBase">
            <summary>
            通用的数据模型基类
            </summary>
        </member>
        <member name="P:DotNEToolkit.DataModels.ModelBase.ID">
            <summary>
            唯一编号
            </summary>
        </member>
        <member name="P:DotNEToolkit.DataModels.ModelBase.Name">
            <summary>
            名字
            </summary>
        </member>
        <member name="P:DotNEToolkit.DataModels.ModelBase.Description">
            <summary>
            描述
            </summary>
        </member>
        <member name="P:DotNEToolkit.DataModels.ModelBase.CreationTime">
            <summary>
            创建时间
            </summary>
        </member>
        <member name="P:DotNEToolkit.DataModels.ModelBase.Creator">
            <summary>
            创建者
            </summary>
        </member>
        <member name="F:DotNEToolkit.Extentions.HexNumberOptions.None">
            <summary>
            没有选项
            </summary>
        </member>
        <member name="F:DotNEToolkit.Extentions.HexNumberOptions.WithPrefix">
            <summary>
            带有0x前缀
            </summary>
        </member>
        <member name="T:DotNEToolkit.Extentions.Bytes">
            <summary>
            操作字节数组的帮助类
            </summary>
        </member>
        <member name="M:DotNEToolkit.Extentions.Bytes.JoinHexNumber(System.Byte[],System.String,DotNEToolkit.Extentions.HexNumberOptions)">
            <summary>
            把一个字节数组转成十六进制字符串
            不带0x前缀
            </summary>
            <param name="source"></param>
            <param name="separator">每个字节之间的分隔符</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Extentions.Bytes.SplitBytes(System.String,System.String)">
            <summary>
            把一个十六进制的字符串分隔成byte数组
            </summary>
            <param name="hex">要分隔的字符串</param>
            <param name="separator">分隔符</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Extentions.Bytes.Compare(System.Byte[],System.Byte[])">
            <summary>
            对两个字节数组进行比较操作
            </summary>
            <param name="array1">要比较的第一个字节数组</param>
            <param name="array2">要比较的第二个字节数组</param>
            <returns>每个字节是否相等</returns>
        </member>
        <member name="T:DotNEToolkit.Extentions.EnumMember">
            <summary>
            描述一个枚举成员
            </summary>
        </member>
        <member name="P:DotNEToolkit.Extentions.EnumMember.Name">
            <summary>
            枚举的名字
            </summary>
        </member>
        <member name="P:DotNEToolkit.Extentions.EnumMember.Value">
            <summary>
            枚举的值
            </summary>
        </member>
        <member name="P:DotNEToolkit.Extentions.EnumMember.Description">
            <summary>
            枚举的描述信息
            使用Attribute指定
            </summary>
        </member>
        <member name="M:DotNEToolkit.Extentions.Enumerations.GetMemberList``1">
            <summary>
            把一个枚举类型转换成实体集合
            </summary>
            <typeparam name="T">要转换的枚举类型</typeparam>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Extentions.Enumerations.ParseDescription(System.Reflection.FieldInfo)">
            <summary>
            解析枚举字段上的DescriptionAttribute特性
            </summary>
            <param name="enumField"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.DirectoryExtentions">
            <summary>
            对目录的扩展类
            </summary>
        </member>
        <member name="M:DotNEToolkit.DirectoryExtentions.EnumerateDirectories(System.String)">
            <summary>
            枚举某个目录，会把异常截住
            </summary>
            <param name="dir">要枚举的目录</param>
            <returns>子目录列表</returns>
        </member>
        <member name="M:DotNEToolkit.DirectoryExtentions.EnumerateFiles(System.String)">
            <summary>
            枚举某个目录下的所有文件，会把异常截住
            如果某个目录没有访问权限，.NET自带的枚举函数会抛异常
            </summary>
            <param name="dir">要枚举的目录</param>
            <returns>文件列表</returns>
        </member>
        <member name="M:DotNEToolkit.DirectoryExtentions.DirectorySize(System.String)">
            <summary>
            获取目录大小
            </summary>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.DirectoryExtentions.DirectoryReadableSize(System.String)">
            <summary>
            以易于阅读的格式输出文件大小（例如 1K 234M 2G等）
            </summary>
            <param name="size">以字节为单位的大小</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.DirectoryExtentions.DirectoryReadableSize(System.Int64)">
            <summary>
            以易于阅读的格式输出文件大小（例如 1K 234M 2G等）
            </summary>
            <param name="size">以字节为单位的大小</param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Streams">
            <summary>
            封装对流的一些操作
            </summary>
        </member>
        <member name="F:DotNEToolkit.Streams.BufferSize">
            <summary>
            一次读取1024个字节
            </summary>
        </member>
        <member name="M:DotNEToolkit.Streams.ReadFull(System.IO.Stream,System.Int64)">
            <summary>
            从流中读取数据，一直读满size个字节为止
            </summary>
            <param name="stream"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Streams.ReadFull(System.Func{System.Byte[],System.Int32,System.Int32,System.Int32},System.Int32)">
            <summary>
            读取指定大小的数据
            </summary>
            <param name="readFunc"></param>
            <param name="howMuch">要读取的字节数</param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Sockets">
            <summary>
            封装可以快速操作Socket的方法
            </summary>
        </member>
        <member name="M:DotNEToolkit.Sockets.ReceiveFull(System.Net.Sockets.Socket,System.Byte[])">
            <summary>
            读取一段完整的数据
            </summary>
            <param name="socket"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Sockets.SendFull(System.Net.Sockets.Socket,System.Byte[])">
            <summary>
            发送一段完整的数据
            </summary>
            <param name="socket"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.HttpClient">
            <summary>
            提供发送HTTP请求的函数
            </summary>
        </member>
        <member name="T:DotNEToolkit.BlankCharacterOptions">
            <summary>
            指定如何处理INI文件里的空白字符
            </summary>
        </member>
        <member name="F:DotNEToolkit.BlankCharacterOptions.None">
            <summary>
            遇到空白字符不做处理
            </summary>
        </member>
        <member name="F:DotNEToolkit.BlankCharacterOptions.Delete">
            <summary>
            删除两端的空白字符
            </summary>
        </member>
        <member name="F:DotNEToolkit.BlankCharacterOptions.OnlyDeleteFirst">
            <summary>
            只删除开头的空白字符
            </summary>
        </member>
        <member name="F:DotNEToolkit.BlankCharacterOptions.OnlyDeleteLast">
            <summary>
            只删除结尾的空白字符
            </summary>
        </member>
        <member name="F:DotNEToolkit.BlankCharacterOptions.DeleteAll">
            <summary>
            删除所有空白字符
            </summary>
        </member>
        <member name="T:DotNEToolkit.INIReader">
            <summary>
            INI文件读写器
            </summary>
        </member>
        <member name="F:DotNEToolkit.INIReader.values">
            <summary>
            section -> values
            </summary>
        </member>
        <member name="T:DotNEToolkit.linux.tail">
            <summary>
            模拟linux的tail工具
            </summary>
        </member>
        <member name="F:DotNEToolkit.linux.tail.sleep_period">
            <summary>
            如果打开文件失败，那么这个值指定重试打开文件的间隔时间
            打开文件成功后，这个值指定每次读取文件的间隔时间
            单位是毫秒
            </summary>
        </member>
        <member name="F:DotNEToolkit.linux.tail.BUFSIZE">
            <summary>
            每次读取的缓冲区大小
            </summary>
        </member>
        <member name="F:DotNEToolkit.linux.tail.NEW_LINE">
            <summary>
            默认的换行符
            </summary>
        </member>
        <member name="T:DotNEToolkit.linux.tail.tail_event_type">
            <summary>
            tail工具的事件
            </summary>
        </member>
        <member name="F:DotNEToolkit.linux.tail.tail_event_type.TAIL_EXIT">
            <summary>
            退出
            </summary>
        </member>
        <member name="T:DotNEToolkit.linux.tail.tail_options">
            <summary>
            tail选项
            </summary>
        </member>
        <member name="F:DotNEToolkit.linux.tail.tail_options.follow">
            <summary>
            same as 'tail -f'
            </summary>
        </member>
        <member name="F:DotNEToolkit.linux.tail.tail_options.readline">
            <summary>
            按行读取，换行符是\n
            </summary>
        </member>
        <member name="F:DotNEToolkit.linux.tail.tail_options.retry">
            <summary>
            如果文件不存在，是否一直重试读取文件
            </summary>
        </member>
        <member name="E:DotNEToolkit.linux.tail.callback">
            <summary>
            第一个参数是tail对象
            第二个参数是事件类型
            第三个参数是事件类型所关联的数据
            第四个参数是userData
            </summary>
        </member>
        <member name="P:DotNEToolkit.linux.tail.period">
            <summary>
            读取文件的间隔时间
            </summary>
        </member>
        <member name="P:DotNEToolkit.linux.tail.bufsize">
            <summary>
            每次读取文件的缓冲区大小
            </summary>
        </member>
        <member name="P:DotNEToolkit.linux.tail.encoding">
            <summary>
            读取文件的时候的编码格式
            </summary>
        </member>
        <member name="M:DotNEToolkit.linux.tail.trim_line(System.Char[])">
            <summary>
            如果不是完整的一行数据，那么把不完整的数据截断并保存到remain里
            </summary>
            <param name="chars">返回不完整的行的数据</param>
        </member>
        <member name="M:DotNEToolkit.Collections.GetValue``1(System.Collections.IDictionary,System.String)">
            <summary>
            如果不存在对应的Key，那么直接抛异常
            </summary>
            <typeparam name="T"></typeparam>
            <param name="map"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Collections.GetJSONObject``1(System.Collections.IDictionary,System.String,``0)">
            <summary>
            从一个字典里获取一个JSON格式的对象
            如果不存在该参数或者序列化失败, 那么返回defaultValue
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="parameters"></param>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Collections.Join(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            把字符串数组中的所有元素放入一个字符串。
            </summary>
            <param name="list"></param>
            <param name="separator">指定要使用的分隔符</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Collections.HasDuplicated(System.Collections.Generic.List{System.String})">
            <summary>
            判断一个集合里是否有重复元素
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Internals.Confguration">
            <summary>
            读取配置的类
            </summary>
        </member>
        <member name="T:DotNEToolkit.JSONHelper">
            <summary>
            JSON函数
            </summary>
        </member>
        <member name="M:DotNEToolkit.JSONHelper.ParseDirectory``1(System.String,System.String)">
            <summary>
            把一个目录里所有的符合pattern的文件序列化成一个List
            </summary>
            <typeparam name="T"></typeparam>
            <param name="searchDir"></param>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.JSONHelper.ParseFile``1(System.String)">
            <summary>
            把一个json文件序列化成C#对象
            该函数不会对异常做处理，异常由调用者截获并处理
            如果该函数对异常做处理，那么调用者可能不知道出现异常的详细原因
            </summary>
            <typeparam name="TResult">要序列化成的对象类型</typeparam>
            <param name="jsonFile">要序列化的json文件的路径</param>
            <returns>如果序列化失败，那么返回空</returns>
        </member>
        <member name="M:DotNEToolkit.JSONHelper.WriteFile``1(System.String,``0)">
            <summary>
            把一个C#对象序列化成JSON格式并写入到一个文件里
            该函数不会返回错误码，由调用者去截取异常并处理
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="jsonFile"></param>
            <param name="obj"></param>
        </member>
        <member name="T:DotNEToolkit.JSONDatabase">
            <summary>
            把一个json文件当成数据库去用
            </summary>
        </member>
        <member name="M:DotNEToolkit.JSONDatabase.Insert``1(System.String,``0)">
            <summary>
            向一个集合里插入一条数据
            </summary>
            <typeparam name="T">集合里的类型</typeparam>
            <param name="jsonFile">json文件路径</param>
            <param name="item">要插入的元素的实例</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.JSONDatabase.SaveAll``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            保存所有对象，会覆盖JSON文件
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="jsonFile"></param>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.DesktopArea">
            <summary>
            表示一个鼠标区域
            </summary>
        </member>
        <member name="P:DotNEToolkit.DesktopArea.ID">
            <summary>
            桌面区域的唯一标志符
            </summary>
        </member>
        <member name="P:DotNEToolkit.DesktopArea.Area">
            <summary>
            桌面区域
            </summary>
        </member>
        <member name="E:DotNEToolkit.MouseScanner.MouseEnter">
            <summary>
            当鼠标移动到指定区域的时候触发
            </summary>
        </member>
        <member name="T:DotNEToolkit.ObjectCast">
             <summary>
             属性转换类，将一个类的属性值转换给另外一个类的同名属性，注意该类使用的是浅表复制。
             <example>
                    下面几种用法一样:
                    ModuleCast.GetCast(typeof(CarInfo), typeof(ImplCarInfo)).Cast(info, ic);
                    ModuleCast.CastObject《CarInfo, ImplCarInfo》(info, ic);
                    ModuleCast.CastObject(info, ic);
            
                    ImplCarInfo icResult= info.CopyTo《ImplCarInfo》(null);
            
                    ImplCarInfo icResult2 = new ImplCarInfo();
                    info.CopyTo《ImplCarInfo》(icResult2);
             
             </example>
             </summary>
        </member>
        <member name="M:DotNEToolkit.ObjectCast.GetCast(System.Type,System.Type)">
            <summary>
            获取要转换的当前转换类实例
            </summary>
            <param name="sourceType">要转换的源类型</param>
            <param name="targetType">目标类型</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.ObjectCast.#ctor(System.Type,System.Type)">
            <summary>
            以两个要转换的类型作为构造函数，构造一个对应的转换类
            </summary>
            <param name="sourceType"></param>
            <param name="targetType"></param>
        </member>
        <member name="M:DotNEToolkit.ObjectCast.Cast(System.Object,System.Object)">
            <summary>
            将源类型的属性值转换给目标类型同名的属性
            </summary>
            <param name="source"></param>
            <param name="target"></param>
        </member>
        <member name="M:DotNEToolkit.ObjectCast.Cast(System.Object,System.Object,System.String[])">
            <summary>
            将源类型的属性值转换给目标类型同名的属性，排除要过滤的属性名称
            </summary>
            <param name="source"></param>
            <param name="target"></param>
        </member>
        <member name="M:DotNEToolkit.ObjectCast.CastObject``2(``0,``1)">
            <summary>
            转换对象
            </summary>
            <typeparam name="TSource">源类型</typeparam>
            <typeparam name="TTarget">目标类型</typeparam>
            <param name="source">源对象</param>
            <param name="target">目标对象</param>
        </member>
        <member name="T:DotNEToolkit.ObjectCast.CastProperty">
            <summary>
            转换属性对象
            </summary>
        </member>
        <member name="T:DotNEToolkit.ObjectCast.PropertyAccessorHandler">
            <summary>
            属性访问器
            </summary>
        </member>
        <member name="T:DotNEToolkit.ObjectCastExtension">
            <summary>
            对象转换扩展
            </summary>
        </member>
        <member name="M:DotNEToolkit.ObjectCastExtension.CopyTo``1(System.Object,``0,System.String[])">
            <summary>
            将当前对象的属性值复制到目标对象，使用浅表复制
            </summary>
            <typeparam name="T">目标对象类型</typeparam>
            <param name="source">源对象</param>
            <param name="target">目标对象，如果为空，将生成一个</param>
            <returns>复制过后的目标对象</returns>
        </member>
        <member name="T:DotNEToolkit.Parallel">
            <summary>
            并行操作的封装
            </summary>
        </member>
        <member name="T:DotNEToolkit.Parallel.ThreadContext">
            <summary>
            保存线程上下文信息
            </summary>
        </member>
        <member name="P:DotNEToolkit.Parallel.ThreadContext.ID">
            <summary>
            线程ID
            </summary>
        </member>
        <member name="P:DotNEToolkit.Parallel.ThreadContext.Task">
            <summary>
            线程所对应的Task
            </summary>
        </member>
        <member name="F:DotNEToolkit.Parallel.DefaultThreadNumber">
            <summary>
            默认开启5线程运行任务
            </summary>
        </member>
        <member name="M:DotNEToolkit.Parallel.Foreach``1(System.Collections.Generic.IList{``0},System.Int32,System.Action{``0,System.Object},System.Object,System.Action{System.Object})">
            <summary>
            对source集合进行并行操作
            该方法是异步的
            </summary>
            <typeparam name="T"></typeparam>
            <param name="threadNum">要开启的线程数量</param>
            <param name="source"></param>
            <param name="action"></param>
            <param name="userData"></param>
            <param name="callback">当所有action都运行完了之后的callback</param>
        </member>
        <member name="T:DotNEToolkit.Processes">
            <summary>
            提供进程相关的帮助函数
            </summary>
        </member>
        <member name="M:DotNEToolkit.Processes.ClearExisting(System.Diagnostics.Process)">
            <summary>
            清空某个进程里的输出缓冲区里的数据
            </summary>
            <param name="proc">要清空的进程</param>
        </member>
        <member name="M:DotNEToolkit.Processes.KillProcess(System.String)">
            <summary>
            根据进程名字关闭一个进程
            </summary>
            <param name="procName">要关闭的进程名字，注意该进程名字不带后缀名（.exe）</param>
        </member>
        <member name="M:DotNEToolkit.Processes.CreateProcess(System.String,System.String)">
            <summary>
            创建一个标准输入输出都重定向了的进程
            </summary>
            <param name="exe"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.DotNETCode">
            <summary>
            DotNEToolkit的返回值
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.SUCCESS">
            <summary>
            成功
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.FAILED">
            <summary>
            失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.UNKNOWN_EXCEPTION">
            <summary>
            异常
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.LOAD_CONFIG_FAILED">
            <summary>
            加载配置文件失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.INVALID_PARAMS">
            <summary>
            无效的参数
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.NOT_SUPPORTED">
            <summary>
            不支持的操作
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.FILE_NOT_FOUND">
            <summary>
            文件不存在
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.READ_FAILED">
            <summary>
            读数据失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.WRITE_FAILED">
            <summary>
            写数据失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.TIMEOUT">
            <summary>
            操作超时
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.OPEN_FILE_FAILED">
            <summary>
            打开文件失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.SYS_ERROR">
            <summary>
            调用API失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.JSON_INVALID_FORMAT">
            <summary>
            无效的JSON格式
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.FILE_WRITE_FAILED">
            <summary>
            写文件失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.FILE_PERMISSION_ERROR">
            <summary>
            没有权限
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.IPC_SEND_FAILED">
            <summary>
            发送消息异常
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.CREATE_PROC_FAILED">
            <summary>
            创建进程失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.CREATE_HOSTED_MODULE_FAILED">
            <summary>
            创建IHostedModule失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.DotNETCode.INIT_HOSTED_MODULE_FAILED">
            <summary>
            初始化IHostedModule失败
            </summary>
        </member>
        <member name="T:DotNEToolkit.Reflections">
            <summary>
            反射工具函数
            </summary>
        </member>
        <member name="M:DotNEToolkit.Reflections.GetClassAttribute``2">
            <summary>
            获取某个类上的自定义特性
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <typeparam name="TClass"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.SDK.libvlc.QuickPlay(System.String,System.IntPtr)">
            <summary>
            封装libvlc的快速播放逻辑，传递一个窗口句柄即可
            带自动重连功能
            </summary>
            <param name="drawable"></param>
        </member>
        <member name="T:DotNEToolkit.SingletonObject`1">
            <summary>
            表示一个单例对象
            </summary>
            <typeparam name="T">单例类的类型</typeparam>
        </member>
        <member name="M:DotNEToolkit.SingletonObject`1.Initialize">
            <summary>
            单例对象初始化
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.SingletonObject`1.Release">
            <summary>
            释放单例对象占用的资源
            </summary>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.TcpFramework.IDataResolver">
            <summary>
            TCP包头解析器。 
            
            TcpFramework假设每一次的TCP通讯总是以报文为单位。报文由报文头+报文内容组成。
            其中报文头的格式是固定，且长度固定。报文内容可以是不定长的，且报文头里总是包含报文内容长度信息。
            
            TcpFramework总是用固定长度的报文头缓冲（例如固定的20个字节）接收报文头。从而确定接下来
            需要接收的报文内容的长度。然后根据该长度来安排接下来的接收过程。接收事件的触发也总是尽量以接收到
            该次报文的所有字节后再触发（当报文内容长度大于最大缓冲大小时，同一个报文可能会触发多次接收事件）。
            因此TcpFramework的接收数据的过程总是周而复始的执行  
              1. 接收报文头  
              2. 接收报文内容(1次或多次)...
            
            在处理报文头的时候有2种情况：
              1. TcpFramework收到了正确的报文头。那么IDataResolver只需要根据约定的报文头格式解析出里面包含的报文长度即可
              2. 接收过程由于某种原因，收到的报文头发生了错位。一旦发生了错位，接下来所有正常的接收过程都会被打乱。
                 因此TcpFramework需要用某种方式来让接收过程重现回到正确的步骤上。这里有我们将采取断开客户端连接的方式解决
               
            IDataResolver接口所提供的主要功能就是
              1. 提供方法来验证报文头的正确性
              2. 确定报文内容的长度。
            </summary>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.IDataResolver.ResolveHeader(System.Byte[],System.Int32)">
            <summary>
            解析TCP报文头. 
            根据业务逻辑所定义的TCP报文头格式来解析本次接收中接下来需要接收的TCP报文内容的长度
            </summary>
            <param name="headerBuffer">报文头缓冲</param>
            <param name="offset">本次分析的报文头的偏移</param>
            <returns>接下来需要接收报文的大小(整个报文减去报文头的长度)，返回小于0 说明接收到的报文头无效</returns>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.IDataResolver.HeaderSize">
            <summary>
            报文头的大小
            </summary>
        </member>
        <member name="T:DotNEToolkit.TcpFramework.NetEventArgs">
            <summary> 
            服务器程序的事件参数,包含了激发该事件的Socket对象 
            </summary> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.NetEventArgs.#ctor(System.Net.Sockets.Socket,System.Net.Sockets.SocketError)">
            <summary> 
            构造函数 
            </summary> 
            <param name="client">客户端会话</param> 
        </member>
        <member name="P:DotNEToolkit.TcpFramework.NetEventArgs.ClientSocket">
            <summary> 
            获得激发该事件的会话对象 
            </summary> 
        </member>
        <member name="P:DotNEToolkit.TcpFramework.NetEventArgs.ClientHandle">
            <summary>
            获取Socket的Handle
            </summary>
        </member>
        <member name="T:DotNEToolkit.TcpFramework.DataReceivedEventArgs">
            <summary>
            TCP数据接收事件参数
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.DataReceivedEventArgs.Data">
            <summary>
            接收到的数据缓冲区
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.DataReceivedEventArgs.StartOffset">
            <summary>
            接收到的数据在缓冲区的起始位置
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.DataReceivedEventArgs.DataSize">
            <summary>
            接收到的数据长度
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.DataReceivedEventArgs.RemainSize">
            <summary>
            当前报文剩余字节数
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.DataReceivedEventArgs.PackageIndex">
            <summary>
            如果message太大一次接收不完，该属性将记录
            接收该message时所触发回调的Index. 从0开始计数
            </summary>
        </member>
        <member name="T:DotNEToolkit.TcpFramework.Session">
            <summary> 
            客户端与服务器之间通讯的会话类。该会话类主要管理某个Socket接收事务，
            包括分包管理，缓冲区等等。
            </summary> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.Session.#ctor(System.Byte[],System.Int32)">
            <summary>
            构造接收通讯会话。Session中记录了TCP Message接收时需要保存的一些中间变量，如TCP Message的
            头，接收Message使用的缓冲区，剩余message的长度等等。为了减少内存碎片，Session在接收TCP 
            Message头时直接使用BufferManager预先分配的大块内存。然后再根据TCP Message头中定义的message
            长度，来动态决定下一次需要接收的数据大小，Socket接收缓冲区。接收完毕后，直接将缓冲区传递给上层应用，可以避免
            内存的复制。
            </summary>
            <param name="BufferOffset">session使用的缓冲区偏移</param>
            <param name="buffer">接收缓冲区</param>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.Session.ID">
            <summary> 
            返回会话的ID. 小于0 则为未连接
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.Session.RemoteEndPoint">
            <summary>
            远端接入点，用于调试或显示
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.Session.ClientSocket">
            <summary> 
            获得与客户端会话关联的Socket对象 
            </summary> 
        </member>
        <member name="P:DotNEToolkit.TcpFramework.Session.Remaining">
            <summary>
            本次处理的报文接收中剩余的字节数
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.Session.Expected">
            <summary>
            下一次接收期望的数据大小
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.Session.DataInBuffer">
            <summary>
            当前buffer里保存的数据长度
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.Session.PackageIndex">
            <summary>
            如果一个message过大，一次接收不完。
            该字段记录已经接收的该message并触发回调的次数
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.Session.ReceiveBuffer">
            <summary>
            Message缓冲区
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.Session.BufferOffset">
            <summary>
            在接收下一次数据时，应该从该偏移位置保存接收到的数据。
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.Session.EmptyMsgCount">
            <summary>
            记录连续收到的空消息事件记录. 在很多情况下，当远端socket断开时，
            异步接收函数不会收到ConnectionReset错误。而是直接返回空消息。如果服务器连续n次接收到空消息，
            那么可以认为远端Socket已经断开。
            </summary>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.Session.SetSocket(System.Net.Sockets.Socket)">
            <summary>
            设置Session关联的Socket
            </summary>
            <param name="cliSocket"></param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.Session.Close">
            <summary> 
            关闭会话 
            </summary> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.Session.GetHashCode">
            <summary> 
            使用Socket对象的Handle值作为HashCode,它具有良好的线性特征. 
            </summary> 
            <returns></returns> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.Session.Equals(System.Object)">
            <summary> 
            返回两个Session是否代表同一个客户端 
            </summary> 
            <param name="obj"></param> 
            <returns></returns> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.Session.ToString">
            <summary> 
            重载ToString()方法,返回Session对象的特征 
            </summary> 
            <returns></returns> 
        </member>
        <member name="T:DotNEToolkit.TcpFramework.SessionManager">
            <summary>
            SessionManager主要用于管理和回收服务器，客户端直接通讯的Session。
            为减少内存碎片，提高效率，SessionManager将预先分配一大块内存区域作为缓冲，供多个Session同时使用。
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.SessionManager.blockSize">
            <summary>
            每片message头的大小
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.SessionManager.freeSessions">
            <summary>
            记录可用的bufferIndex. 如果freeSessions有Size限制，
            可以考虑使用freeBufferStack来减少内存消耗
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.SessionManager.buffer">
            <summary>
            缓冲区
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.SessionManager.unusedOffset">
            <summary>
            已分配出的buffer offset
            </summary>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.SessionManager.#ctor(System.Int32,System.Int32)">
            <summary>
            初始化函数
            </summary>
            <param name="max">最大的缓冲数量</param>
            <param name="blockSize">每个缓冲区的大小</param>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.SessionManager.Buffer">
            <summary>
            报文头接收缓冲
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.SessionManager.BlockSize">
            <summary>
            每片缓冲长度
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.SessionManager.Capacity">
            <summary>
            可以支持的session最大数量
            </summary>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.SessionManager.RequestSession(System.Net.Sockets.Socket)">
            <summary>
            申请一个会话对象
            </summary>
            <param name="cliSock">通讯Socket</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.SessionManager.ReleaseSession(DotNEToolkit.TcpFramework.Session)">
            <summary>
            回收会话对象
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.SessionManager.Clear">
            <summary>
            重置BufferManager
            </summary>
        </member>
        <member name="T:DotNEToolkit.TcpFramework.SocketAsyncEventArgsPool">
            <summary>
            基于MSDN的SocketAsyncEventArgs的例子 http://msdn2.microsoft.com/en-us/library/system.net.sockets.socketasynceventargs.socketasynceventargs.aspx
            对 SocketAsyncEventArgs进行重用管理，防止GC回收无用的SocketAsyncEventArgs，浪费系统资源
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.SocketAsyncEventArgsPool.pool">
            <summary>
            SocketAsyncEventArgs栈
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.SocketAsyncEventArgsPool.Count">
            <summary>
            返回SocketAsyncEventArgs池中的 数量
            </summary>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.SocketAsyncEventArgsPool.#ctor(System.Int32)">
            <summary>
            初始化SocketAsyncEventArgs池
            </summary>
            <param name="capacity">最大可能使用的SocketAsyncEventArgs对象.</param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.SocketAsyncEventArgsPool.Pop">
            <summary>
            弹出一个SocketAsyncEventArgs
            </summary>
            <returns>SocketAsyncEventArgs removed from the pool.</returns>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.SocketAsyncEventArgsPool.Push(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            添加一个 SocketAsyncEventArgs
            </summary>
            <param name="item">SocketAsyncEventArgs instance to add to the pool.</param>
        </member>
        <member name="T:DotNEToolkit.TcpFramework.TcpCli">
            <summary> 
            提供Tcp网络连接服务的客户端类 
            1.使用异步的Socket通讯函数BeginXXX作为基础，完成网络通讯功能。
              接收与发送过程相互不干扰，实现了TCP全双工。
            2.客户端连接服务成功后，将立刻启动接收过程。每次接收首先接收Message头，然后根据
              报文头解析出来的剩余报文长度，安排一次或者多次的接收。由此来处理分包问题。当报文的长度
              小于可以接受的缓冲区大小时，服务类将会等收到所有报文后触发数据接收事件；否则服务类将会
            </summary> 
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpCli.DefaultBufferSize">
            <summary> 
            缺省接收数据缓冲区大小8K 
            </summary> 
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpCli.DefaultMaxEmptyMessage">
            <summary>
            连续接收到空消息的次数大于该值，服务器将会关闭该连接
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpCli.session">
            <summary> 
            接收数据会话 
            </summary> 
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpCli.receiveBuffer">
            <summary>
            receive buffer
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpCli.headerResolver">
            <summary>
            头部解析
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpCli.dataReceivedCallback">
            <summary>
            接收数据回调Callback
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpCli.dataSentCallback">
            <summary>
            data sent callback
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpCli.logger">
            <summary>
            Logger
            </summary>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.#ctor(DotNEToolkit.TcpFramework.IDataResolver,System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="headerSize">约定的TCP Message头大小</param>
            <param name="headerResolver">报文头解析函数</param>
        </member>
        <member name="E:DotNEToolkit.TcpFramework.TcpCli.Connected">
            <summary> 
            已连接事件 
            </summary> 
        </member>
        <member name="E:DotNEToolkit.TcpFramework.TcpCli.Disconnected">
            <summary> 
            连接断开事件 
            </summary> 
        </member>
        <member name="E:DotNEToolkit.TcpFramework.TcpCli.DataReceived">
            <summary> 
            接收到数据报文事件 
            </summary> 
        </member>
        <member name="E:DotNEToolkit.TcpFramework.TcpCli.DataSent">
            <summary>
            发送结束
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.TcpCli.IsConnected">
            <summary> 
            返回客户端与服务器之间的连接状态 
            </summary> 
        </member>
        <member name="P:DotNEToolkit.TcpFramework.TcpCli.MaxEmptyMessage">
            <summary>
            如果某个clientSocket                                     
            连续接收到空消息的次数大于该值，服务器将会关闭该连接
            </summary>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.BeginConnect(System.String,System.Int32)">
            <summary> 
            连接服务器 
            </summary> 
            <param name="ip">服务器IP地址</param> 
            <param name="port">服务器端口</param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.SendAsync(System.Byte[])">
            <summary> 
            发送数据报文 
            </summary> 
            <param name="datagram"></param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.Disconnect">
            <summary> 
            关闭连接 
            </summary> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.Close(System.Net.Sockets.SocketError)">
            <summary>
            内部调用。会触发断开事件
            </summary>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.OnDataSent(System.IAsyncResult)">
            <summary> 
            数据发送完成处理函数 
            </summary> 
            <param name="iar"></param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.OnConnected(System.IAsyncResult)">
            <summary> 
            建立Tcp连接后处理过程 
            </summary> 
            <param name="iar">异步Socket</param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.OnDataReceived(System.IAsyncResult)">
            <summary> 
            数据接收处理函数 
            </summary> 
            <param name="iar">异步Socket</param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.ReceiveData(DotNEToolkit.TcpFramework.Session,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            接收数据
            </summary>
            <param name="session"></param>
            <param name="dataInBuffer">当前buffer已有的数据长度</param>
            <param name="expectedSize">期望接收的数据大小</param>
            <param name="packageIndex">下一次接收的包</param>
            <param name="remaining">当前会话剩余的字节数</param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.ResumeLastReceive(DotNEToolkit.TcpFramework.Session)">
            <summary>
            根据当前记录重试上次的任务
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.ResolveHeader(DotNEToolkit.TcpFramework.Session)">
            <summary>
            解析报文头
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpCli.HandleData(DotNEToolkit.TcpFramework.Session,System.Int32)">
            <summary>
            处理收到的报文数据
            </summary>
            <param name="session"></param>
            <param name="receivedSize"></param>
        </member>
        <member name="T:DotNEToolkit.TcpFramework.TcpSvr">
            <summary> 
            提供TCP连接服务的服务器类。 
            
            1. 使用异步的Socket事件作为基础，完成全双工的网络通讯功能. 
            2. 该服务类每次Accept客户端连接后，将立刻启动接收过程。每次接收首先接收Message头，然后根据
               报文头解析出来的剩余报文长度，安排一次或者多次的接收。由此来处理分包问题。当报文的长度
               小于可以接受的缓冲区大小时，服务类将会等收到所有报文后触发数据接收事件；否则服务类将会
               触发多次数据接收事件，直至报文接收完成。然后进入下一次接收状态。
            3. 服务类发送时也是用异步发送过程。与发送过程相互不干扰。
            </summary> 
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.DefaultConcurrentLevel">
            <summary>
            默认并发级别，即同一时刻访问sessionTable的并发线程数。
            请参考ConcurrentDictionary concurrentLevel定义。
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.DefaultMaxClient">
            <summary> 
            默认的服务器最大连接客户端端数据 
            </summary> 
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.DefaultHeaderSize">
            <summary> 
            缺省Header大小8K 
            </summary> 
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.DefaultBacklog">
            <summary>
            TCP Listen backlog
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.DefaultBufferSize">
            <summary>
            接收缓冲最大大小
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.DefaultMaxEmptyMessage">
            <summary>
            连续接收到空消息的次数大于该值，服务器将会关闭该连接
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.concurrentLevel">
            <summary>
            并发级别。定义为同一时刻访问sessionTable的并发线程数。
            请参考ConcurrentDictionary concurrentLevel定义。
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.dataReceivedCallback">
            <summary>
            接收数据回调Callback
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.connectionAcceptedCallback">
            <summary>
            connection Accepted callback
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.dataSentCallback">
            <summary>
            data sent callback
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.serverIP">
            <summary>
            服务器程序监听的IP地址
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.port">
            <summary> 
            服务器程序使用的端口 
            </summary> 
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.isRun">
            <summary> 
            服务器的运行状态 
            </summary> 
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.listenSocket">
            <summary> 
            服务器使用的异步Socket类, 
            </summary> 
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.sessionTable">
            <summary> 
            保存所有客户端会话的哈希表 
            </summary> 
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.sessionManager">
            <summary>
            Session Manager
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.headerResolver">
            <summary>
            TCP数据解析器
            </summary>
        </member>
        <member name="F:DotNEToolkit.TcpFramework.TcpSvr.logger">
            <summary>
            Logger
            </summary>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.#ctor(System.Net.IPAddress,System.UInt16,DotNEToolkit.TcpFramework.IDataResolver,System.Int32,System.Int32,System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="ipAddress">服务IP</param>
            <param name="port">服务器端监听的端口号</param>
            <param name="headerResolver">报文头解析函数</param>
            <param name="maxClient">服务器最大容纳客户端数</param>
            <param name="headerSize">报文头长度</param>
            <param name="maxRecvBufSize">每次接收报文的最大大小</param>
            <param name="concurrentLevel">服务器并发度。主要体现在Listener的backlog以及sessionMap的并发级别</param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.#ctor(System.String,System.UInt16,DotNEToolkit.TcpFramework.IDataResolver,System.Int32,System.Int32,System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="ipAddress">服务IP</param>
            <param name="port">服务器端监听的端口号</param>
            <param name="headerResolver">报文头解析函数</param>
            <param name="maxClient">服务器最大容纳客户端数</param>
            <param name="headerSize">报文头长度</param>
            <param name="maxRecvBufSize">每次接收报文的最大大小</param>
            <param name="concurrentLevel">服务器并发度。主要体现在Listener的backlog以及sessionMap的并发级别</param>
        </member>
        <member name="E:DotNEToolkit.TcpFramework.TcpSvr.ClientConnected">
            <summary> 
            客户端建立连接事件 
            </summary> 
        </member>
        <member name="E:DotNEToolkit.TcpFramework.TcpSvr.ClientClosed">
            <summary> 
            客户端关闭事件 
            </summary> 
        </member>
        <member name="E:DotNEToolkit.TcpFramework.TcpSvr.ServerFull">
            <summary> 
            服务器已经满事件 
            </summary> 
        </member>
        <member name="E:DotNEToolkit.TcpFramework.TcpSvr.DataReceived">
            <summary> 
            服务器接收到数据事件 
            </summary> 
        </member>
        <member name="E:DotNEToolkit.TcpFramework.TcpSvr.DataSent">
            <summary>
            数据发送结束
            </summary>
        </member>
        <member name="P:DotNEToolkit.TcpFramework.TcpSvr.ServerSocket">
            <summary> 
            服务器的Socket对象 
            </summary> 
        </member>
        <member name="P:DotNEToolkit.TcpFramework.TcpSvr.Capacity">
            <summary> 
            服务器可以容纳客户端的最大能力 
            </summary> 
        </member>
        <member name="P:DotNEToolkit.TcpFramework.TcpSvr.SessionCount">
            <summary> 
            当前的客户端连接数 
            </summary> 
        </member>
        <member name="P:DotNEToolkit.TcpFramework.TcpSvr.IsRun">
            <summary> 
            服务器运行状态 
            </summary> 
        </member>
        <member name="P:DotNEToolkit.TcpFramework.TcpSvr.MaxEmptyMessage">
            <summary>
            如果某个clientSocket                                     
            连续接收到空消息的次数大于该值，服务器将会关闭该连接
            </summary>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.Start">
            <summary> 
            启动服务器程序,开始监听客户端请求 
            </summary> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.Stop">
            <summary> 
            停止服务器程序,所有与客户端的连接将关闭 
            </summary> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.CloseAllClient">
            <summary> 
            关闭所有的客户端会话,与所有的客户端连接会断开。
            该命令将不触发ClientClosed事件
            </summary> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.CloseClient(System.Int32)">
            <summary> 
            关闭一个与客户端之间的会话 
            </summary> 
            <param name="clientSocket">需要关闭的客户端会话对象</param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.SendAsync(System.Int32,System.Byte[])">
            <summary> 
            发送数据 
            </summary> 
            <param name="clientSession">接收数据的客户端会话</param> 
            <param name="datagram">数据报文</param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.GetClientSocket(System.Int32)">
            <summary>
            获取Client Socket
            </summary>
            <param name="clientHandle"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.Initialize(System.Net.IPAddress,System.UInt16,DotNEToolkit.TcpFramework.IDataResolver,System.Int32,System.Int32,System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="ipAddress">服务IP</param>
            <param name="port">服务器端监听的端口号</param>
            <param name="headerResolver">报文头解析函数</param>
            <param name="maxClient">服务器最大容纳客户端数</param>
            <param name="recvBufSize">接收缓冲的大小</param>
            <param name="concurrentLevel">服务器并发度。主要体现在Listener的backlog以及sessionMap的并发级别</param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.OnConnectionAccepted(System.IAsyncResult)">
            <summary> 
            客户端连接处理函数 
            </summary> 
            <param name="iar">欲建立服务器连接的Socket对象</param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.OnDataReceived(System.IAsyncResult)">
            <summary> 
            接受数据完成处理函数. 接收到报文后，server首先判断session当前的状态：
            1. 接收报文头的状态（Session.Remaining==0）: 
               服务将调用headerResolver解析报文头部，确定接下来的报文大小。同时创建接收缓冲。
            2. 接收报文状态(Session.Remaining>0)：
               收到报文。服务将触发接收报文事件
            
            </summary> 
            <param name="iar">目标客户端Socket</param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.OnDataSent(System.IAsyncResult)">
            <summary> 
            发送数据完成处理函数 
            </summary> 
            <param name="iar">目标客户端Socket</param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.CloseSession(DotNEToolkit.TcpFramework.Session,System.Net.Sockets.SocketError)">
            <summary> 
            关闭一个客户端Session. 
            </summary> 
            <param name="session">目标session对象</param> 
            <param name="errorCode">客户端退出的SocketError Code</param> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.FindSession(System.Int32)">
            <summary> 
            通过Socket对象查找ClientSocket对象 
            </summary> 
            <param name="client"></param> 
            <returns>找到的Session对象,如果为null,说明并不存在该回话</returns> 
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.ResolveHeader(DotNEToolkit.TcpFramework.Session)">
            <summary>
            解析报文头
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.HandleData(DotNEToolkit.TcpFramework.Session,System.Int32)">
            <summary>
            处理收到的报文数据
            </summary>
            <param name="session"></param>
            <param name="receivedSize"></param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.ReceiveData(DotNEToolkit.TcpFramework.Session,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            接收数据
            </summary>
            <param name="session"></param>
            <param name="dataInBuffer">当前buffer已有的数据长度</param>
            <param name="expectedSize">期望接收的数据大小</param>
            <param name="packageIndex">下一次接收的包</param>
            <param name="remaining">当前会话剩余的字节数</param>
        </member>
        <member name="M:DotNEToolkit.TcpFramework.TcpSvr.ResumeLastReceive(DotNEToolkit.TcpFramework.Session)">
            <summary>
            根据当前记录重试上次的任务
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:DotNEToolkit.Win32APIHelper.GetWindowText(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            获取某个窗口中，某个位置的控件上的文本
            </summary>
            <param name="hWnd">要获取的窗口的句柄</param>
            <param name="x">要获取文本的控件的x坐标</param>
            <param name="y">要获取文本的控件的y坐标</param>
            <returns>获取到的文本</returns>
        </member>
        <member name="T:DotNEToolkit.MMSYSERR">
            <summary>
            返回值定义
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.wavehdr_tag.lpData">
            <summary>
            Pointer to the waveform buffer.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.wavehdr_tag.dwBufferLength">
            <summary>
            Length, in bytes, of the buffer.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.wavehdr_tag.dwBytesRecorded">
            <summary>
            When the header is used in input, specifies how much data is in the buffer.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.wavehdr_tag.dwUser">
            <summary>
            User data.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.uMsgEnum.WIM_CLOSE">
            <summary>
            Sent when the device is closed using the waveInClose function.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.uMsgEnum.WIM_DATA">
            <summary>
            Sent when the device driver is finished with a data block sent using the waveInAddBuffer function.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.uMsgEnum.WIM_OPEN">
            <summary>
            Sent when the device is opened using the waveInOpen function.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.CALLBACK_EVENT">
            <summary>
            The dwCallback parameter is an event handle.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.CALLBACK_FUNCTION">
            <summary>
            The dwCallback parameter is a callback procedure address.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.CALLBACK_NULL">
            <summary>
            No callback mechanism. This is the default setting.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.CALLBACK_THREAD">
            <summary>
            The dwCallback parameter is a thread identifier.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.CALLBACK_WINDOW">
            <summary>
            The dwCallback parameter is a window handle.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.WAVE_FORMAT_DIRECT">
            <summary>
            If this flag is specified, the ACM driver does not perform conversions on the audio data.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.WAVE_FORMAT_QUERY">
            <summary>
            The function queries the device to determine whether it supports the given format, but it does not open the device.
            </summary>
        </member>
        <member name="F:DotNEToolkit.waveIn.WAVE_MAPPED">
            <summary>
            The uDeviceID parameter specifies a waveform-audio device to be mapped to by the wave mapper.
            </summary>
        </member>
        <member name="T:DotNEToolkit.waveIn.waveInProcDlg">
            <summary>
            
            </summary>
            <param name="hwi"></param>
            <param name="uMsg"></param>
            <param name="dwInstance"></param>
            <param name="dwParam1">wavehdr_tag指针</param>
            <param name="dwParam2"></param>
        </member>
        <member name="M:DotNEToolkit.waveIn.waveInGetNumDevs">
            <summary>
            获取音频输入设备的数量
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.waveIn.waveInOpen(System.IntPtr@,System.UInt32,System.IntPtr,DotNEToolkit.waveIn.waveInProcDlg,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="phwi">用于返回设备句柄的指针; 如果 dwFlags=WAVE_FORMAT_QUERY, 这里应是 NULL</param>
            <param name="uDeviceID">设备ID; 可以指定为: WAVE_MAPPER, 这样函数会根据给定的波形格式选择合适的设备</param>
            <param name="pwfx">要申请的声音格式</param>
            <param name="dwCallback">回调函数地址或窗口句柄; 若不使用回调机制, 设为 NULL</param>
            <param name="dwInstance">给回调函数的实例数据; 不用于窗口</param>
            <param name="fdwOpen">打开选项</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.waveIn.waveInClose(System.IntPtr)">
            <summary>
            The waveInClose function closes the given waveform-audio input device.
            </summary>
            <param name="phwi"></param>
            <remarks>
            If there are input buffers that have been sent with the waveInAddBuffer function and that haven't been returned to the application, the close operation will fail. Call the waveInReset function to mark all pending buffers as done.
            为了确保关闭成功, 要在调用waveInClose之前先调用waveInReset
            </remarks>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.waveIn.waveInPrepareHeader(System.IntPtr,System.IntPtr,System.UInt32)">
            <summary>
            The waveInPrepareHeader function prepares a buffer for waveform-audio input.
            </summary>
            <param name="hwi">Handle to the waveform-audio input device.</param>
            <param name="pwh">WAVEHDR（wavehdr_tag）结构体指针</param>
            <param name="cbwh">Size, in bytes, of the WAVEHDR structure.</param>
            <remarks>
            The lpData, dwBufferLength, and dwFlags members of the WAVEHDR structure must be set before calling this function (dwFlags must be zero).
            </remarks>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.waveIn.waveInAddBuffer(System.IntPtr,System.IntPtr,System.UInt32)">
            <summary>
            The waveInAddBuffer function sends an input buffer to the given waveform-audio input device. When the buffer is filled, the application is notified.
            把准备好的缓冲区送给硬件
            </summary>
            <param name="hwi"></param>
            <param name="pwh">waveHeader指针</param>
            <param name="cbwh"></param>
            <remarks>
            When the buffer is filled, the WHDR_DONE bit is set in the dwFlags member of the WAVEHDR structure.
            The buffer must be prepared with the waveInPrepareHeader function before it is passed to this function.
            在调用waveInAddBuffer之前必须调用waveInPrepareHeader函数
            </remarks>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.waveIn.waveInUnprepareHeader(System.IntPtr,System.IntPtr,System.UInt32)">
            <summary>
            
            </summary>
            <param name="hwi"></param>
            <param name="pwh">waveHeader指针</param>
            <param name="cbwh"></param>
            <returns></returns>
        </member>
        <member name="F:DotNEToolkit.Win32API.WAIT_FAILED">
            <summary>
            等待信号失败
            </summary>
        </member>
        <member name="F:DotNEToolkit.Win32API.WAVE_FORMAT_PCM">
            <summary>
            flags for wFormatTag field of WAVEFORMAT
            </summary>
        </member>
        <member name="F:DotNEToolkit.Win32API.WM_APPCOMMAND">
            <summary>
            https://docs.microsoft.com/zh-cn/windows/win32/inputdev/wm-appcommand?redirectedfrom=MSDN
            使用WM_APPCOMMAND消息可以实现键盘上的多媒体按键（比如音量控制）
            </summary>
        </member>
        <member name="F:DotNEToolkit.Win32API.APPCOMMAND_CLOSE">
            <summary>
            Close the window (not the application).
            </summary>
        </member>
        <member name="F:DotNEToolkit.Win32API.APPCOMMAND_MICROPHONE_VOLUME_DOWN">
            <summary>
            Decrease microphone volume.
            </summary>
        </member>
        <member name="F:DotNEToolkit.Win32API.APPCOMMAND_MICROPHONE_VOLUME_MUTE">
            <summary>
            Mute the microphone.
            </summary>
        </member>
        <member name="M:DotNEToolkit.Win32API.UpdateWindow(System.IntPtr)">
            <summary>
            立即刷新某个窗口
            会导致窗口重绘
            </summary>
            <param name="hWnd"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.ChildWindowFromPoint(System.IntPtr,DotNEToolkit.Win32API.POINT)">
            <summary>
            返回父窗口中包含了指定点的第一个子窗口的句柄
            </summary>
            <param name="hWndParent"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.WindowFromPoint(DotNEToolkit.Win32API.POINT)">
            <summary>
            返回指定坐标处的窗口句柄
            </summary>
            <param name="Point"></param>
            <returns>如果找到了窗口，则返回窗口句柄，否则返回空句柄</returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.ShellExecute(System.IntPtr,System.String,System.String,System.String,System.String,System.Int32)">
            <summary>
            ShellExecute(IntPtr.Zero, "Open", "C:/Program Files/TTPlayer/TTPlayer.exe", "", "", 1);
            </summary>
            <param name="hwnd"></param>
            <param name="lpOperation"></param>
            <param name="lpFile"></param>
            <param name="lpParameters"></param>
            <param name="lpDirectory"></param>
            <param name="nShowCmd"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.DirectSoundCaptureCreate8(System.IntPtr,System.IntPtr@,System.IntPtr)">
            <summary>
            创建一个DirectSoundCapture8接口
            </summary>
            <param name="pcGuidDevice"></param>
            <param name="ppDSC8"></param>
            <param name="pUnkOuter"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.DirectSoundCreate8(System.IntPtr,System.IntPtr@,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="lpcGuidDevice">
            Address of the GUID that identifies the sound device
            DSDEVID_DefaultPlayback : System-wide default audio playback device. Equivalent to NULL. 
            DSDEVID_DefaultVoicePlayback : Default voice playback device. 
            </param>
            <param name="ppDS8">Address of a variable to receive an IDirectSound8 interface pointer. </param>
            <param name="pUnkOuter"></param>
            <returns></returns>
            <remarks>
            在创建IDirectSound8接口之后必须首先调用SetCooperativeLevel
            </remarks>
        </member>
        <member name="T:DotNEToolkit.Win32API.DSEnumCallback">
            <summary>
            注意：第一个被枚举出来的设备永远都是Primary Sound Driver（主声音捕获设备），所以一般情况下都会忽略第一个设备。主声音捕获设备的意思就是当前用户选择的录音设备。
            The first device enumerated is always called the Primary Sound Driver, and the lpGUID parameter of the callback is NULL. This device represents the preferred playback device set by the user in Control Panel
            </summary>
            <param name="lpGuid">Address of the GUID that identifies the device being enumerated, or NULL for the primary device. This value can be passed to the DirectSoundCreate8 or DirectSoundCaptureCreate8 function to create a device object for that driver.</param>
            <param name="lpcstrDescription">Address of a null-terminated string that provides a textual description of the DirectSound device.</param>
            <param name="lpcstrModule">Address of a null-terminated string that specifies the module name of the DirectSound driver corresponding to this device.</param>
            <param name="lpContext">Address of application-defined data. This is the pointer passed to DirectSoundEnumerate or DirectSoundCaptureEnumerate as the lpContext parameter.</param>
            <returns>Returns TRUE to continue enumerating drivers, or FALSE to stop.</returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.DirectSoundCaptureEnumerate(DotNEToolkit.Win32API.DSEnumCallback,System.Object)">
            <summary>
            DirectSound枚举声音捕获设备的接口
            </summary>
            <param name="lpDSEnumCallback">枚举回调</param>
            <param name="lpContext">上下文信息</param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.WaitForMultipleObjects(System.Int32,System.IntPtr,System.Boolean,System.UInt32)">
            <summary>
            
            </summary>
            <param name="nCount">指定列表中的句柄数量  最大值为MAXIMUM_WAIT_OBJECTS（64）</param>
            <param name="lpHandles">柄数组的指针。lpHandles为指定对象句柄组合中的第一个元素 HANDLE类型可以为（Event，Mutex，Process，Thread，Semaphore）数组</param>
            <param name="bWaitAll">如果为TRUE，表示除非对象都发出信号，否则就一直等待下去；如果FALSE，表示任何对象发出信号即可</param>
            <param name="dwMilliseconds">指定要等候的毫秒数。如设为零，表示立即返回。如指定常数INFINITE，则可根据实际情况无限等待下去</param>
            <returns>
            WAIT_ABANDONED_0：所有对象都发出消息，而且其中有一个或多个属于互斥体（一旦拥有它们的进程中止，就会发出信号）
            WAIT_TIMEOUT：对象保持未发信号的状态，但规定的等待超时时间已经超过
            WAIT_OBJECT_0：所有对象都发出信号，WAIT_OBJECT_0是微软定义的一个宏，你就把它看成一个数字就可以了。例如，WAIT_OBJECT_0 + 5的返回结果意味着列表中的第5个对象发出了信号
            WAIT_IO_COMPLETION：（仅适用于WaitForMultipleObjectsEx）由于一个I/O完成操作已作好准备执行，所以造成了函数的返回
            返回WAIT_FAILED则表示函数执行失败，会设置GetLastError
            </returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.WaitForSingleObject(System.IntPtr,System.UInt32)">
            <summary>
            等待信号量
            </summary>
            <param name="evt"></param>
            <param name="dwMilliseconds"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.ResetEvent(System.IntPtr)">
            <summary>
            重置信号量为无信号状态
            </summary>
            <param name="hEvent"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.GetPrivateProfileString(System.String,System.String,System.String,System.Text.StringBuilder,System.Int32,System.String)">
            <summary>
            Ini文件读取
            </summary>
            <param name="section"></param>
            <param name="key"></param>
            <param name="def"></param>
            <param name="retVal"></param>
            <param name="size"></param>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.Win32API.WritePrivateProfileString(System.String,System.String,System.String,System.String)">
            <summary>
            Ini文件写入
            </summary>
            <param name="section"></param>
            <param name="key"></param>
            <param name="val"></param>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.WinUser">
            <summary>
            WinUser.h
            </summary>
        </member>
        <member name="M:DotNEToolkit.WinUser.RegisterDeviceNotification(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="hRecipient"></param>
            <param name="NotificationFilter"></param>
            <param name="Flags">
            DEVICE_NOTIFY_ALL_INTERFACE_CLASSES：Notifies the recipient of device interface events for all device interface classes. (The dbcc_classguid member is ignored.)This value can be used only if the dbch_devicetype member is DBT_DEVTYP_DEVICEINTERFACE.
            </param>
            <returns></returns>
        </member>
        <member name="M:DotNEToolkit.WinUser.UnregisterDeviceNotification(System.IntPtr)">
            <summary>
            Closes the specified device notification handle.
            </summary>
            <param name="Handle">Device notification handle returned by the RegisterDeviceNotification function.</param>
            <returns></returns>
        </member>
        <member name="T:DotNEToolkit.Dbt">
            <summary>
            Dbt.h
            </summary>
        </member>
        <member name="T:DotNEToolkit.SetupAPI">
            <summary>
            SetupAPI.h
            </summary>
        </member>
        <member name="T:DotNEToolkit.imm">
            <summary>
            imm.h
            </summary>
        </member>
        <member name="T:DotNEToolkit.CLSID">
            <summary>
            COM类型ID
            </summary>
        </member>
        <member name="T:DotNEToolkit.InterfaceID">
            <summary>
            COM接口ID
            </summary>
        </member>
        <member name="T:DotNEToolkit.WindowsServices">
            <summary>
            管理Windows服务
            </summary>
        </member>
        <member name="M:DotNEToolkit.WindowsServices.StartService(System.String)">
            <summary>
            启动一个Windows服务
            </summary>
            <param name="svcName">要启动的服务名字</param>
            <returns>
            启动成功返回true
            如果没找到服务或者启动失败则返回false
            </returns>
        </member>
        <member name="M:DotNEToolkit.WindowsServices.StopService(System.String)">
            <summary>
            停止一个Windows服务
            </summary>
            <param name="svcName">要停止的服务名字</param>
            <returns>
            停止成功返回true
            如果没找到服务或者停止失败则返回false
            </returns>
        </member>
        <member name="M:DotNEToolkit.XmlHelper.ParseFromFile``1(System.String)">
            <summary>
            Parse xml from file path
            </summary>
            <typeparam name="ITEM"></typeparam>
            <param name="filePath"></param>
            <returns></returns>
            <remarks>It is caller's responsibility to catch exception</remarks>
        </member>
        <member name="M:DotNEToolkit.XmlHelper.ToXmlString``1(``0,System.Xml.XmlWriterSettings,System.Xml.Serialization.XmlSerializerNamespaces)">
            <summary>
            Serialize object to xml string
            </summary>
            <typeparam name="ITEM"></typeparam>
            <param name="item"></param>
            <returns></returns>
            <remarks>It is caller's responsibility to catch exception</remarks>
        </member>
        <member name="M:DotNEToolkit.XmlHelper.ToXmlFile``1(``0,System.String)">
            <summary>
            Serialize an object to xml file
            </summary>
            <typeparam name="ITEM"></typeparam>
            <param name="item"></param>
            <param name="filePath"></param>
            <remarks>It is caller's responsibility to catch exception</remarks>
        </member>
    </members>
</doc>
